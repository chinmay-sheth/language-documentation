<h1 id="enum-support-for-enumerations"> enum — Support for enumerations</h1> <div class="versionadded" id="module-enum"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p><strong>Source code:</strong> Lib/enum.py</p> <p>An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.</p> <h2 id="module-contents">
<span class="section-number">8.13.1. </span>Module Contents</h2> <p>This module defines four enumeration classes that can be used to define unique sets of names and values: <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a>, <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a>, and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>. It also defines one decorator, <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a>, and one helper, <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>.</p> <dl class="class"> <dt id="enum.Enum">
<code>class enum.Enum</code> </dt> <dd>
<p>Base class for creating enumerated constants. See section <a class="reference internal" href="#functional-api">Functional API</a> for an alternate construction syntax.</p> </dd>
</dl> <dl class="class"> <dt id="enum.IntEnum">
<code>class enum.IntEnum</code> </dt> <dd>
<p>Base class for creating enumerated constants that are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="enum.IntFlag">
<code>class enum.IntFlag</code> </dt> <dd>
<p>Base class for creating enumerated constants that can be combined using the bitwise operators without losing their <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> membership. <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="enum.Flag">
<code>class enum.Flag</code> </dt> <dd>
<p>Base class for creating enumerated constants that can be combined using the bitwise operations without losing their <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> membership.</p> </dd>
</dl> <dl class="function"> <dt id="enum.unique">
<code>enum.unique()</code> </dt> <dd>
<p>Enum class decorator that ensures only one name is bound to any one value.</p> </dd>
</dl> <dl class="class"> <dt id="enum.auto">
<code>class enum.auto</code> </dt> <dd>
<p>Instances are replaced with an appropriate value for Enum members.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span><code>Flag</code>, <code>IntFlag</code>, <code>auto</code></p> </div> <h2 id="creating-an-enum">
<span class="section-number">8.13.2. </span>Creating an Enum</h2> <p>Enumerations are created using the <code>class</code> syntax, which makes them easy to read and write. An alternative creation method is described in <a class="reference internal" href="#functional-api">Functional API</a>. To define an enumeration, subclass <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> as follows:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum
&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     GREEN = 2
...     BLUE = 3
...
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Enum member values</p> <p>Member values can be anything: <a class="reference internal" href="functions#int" title="int"><code>int</code></a>, <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, etc.. If the exact value is unimportant you may use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> instances and an appropriate value will be chosen for you. Care must be taken if you mix <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> with other values.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Nomenclature</p> <ul class="simple"> <li>The class <code>Color</code> is an <em>enumeration</em> (or <em>enum</em>)</li> <li>The attributes <code>Color.RED</code>, <code>Color.GREEN</code>, etc., are <em>enumeration members</em> (or <em>enum members</em>) and are functionally constants.</li> <li>The enum members have <em>names</em> and <em>values</em> (the name of <code>Color.RED</code> is <code>RED</code>, the value of <code>Color.BLUE</code> is <code>3</code>, etc.)</li> </ul> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Even though we use the <code>class</code> syntax to create Enums, Enums are not normal Python classes. See <a class="reference internal" href="#how-are-enums-different">How are Enums different?</a> for more details.</p> </div> <p>Enumeration members have human readable string representations:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.RED)
Color.RED
</pre> <p>…while their <code>repr</code> has more information:</p> <pre data-language="python">&gt;&gt;&gt; print(repr(Color.RED))
&lt;Color.RED: 1&gt;
</pre> <p>The <em>type</em> of an enumeration member is the enumeration it belongs to:</p> <pre data-language="python">&gt;&gt;&gt; type(Color.RED)
&lt;enum 'Color'&gt;
&gt;&gt;&gt; isinstance(Color.GREEN, Color)
True
&gt;&gt;&gt;
</pre> <p>Enum members also have a property that contains just their item name:</p> <pre data-language="python">&gt;&gt;&gt; print(Color.RED.name)
RED
</pre> <p>Enumerations support iteration, in definition order:</p> <pre data-language="python">&gt;&gt;&gt; class Shake(Enum):
...     VANILLA = 7
...     CHOCOLATE = 4
...     COOKIES = 9
...     MINT = 3
...
&gt;&gt;&gt; for shake in Shake:
...     print(shake)
...
Shake.VANILLA
Shake.CHOCOLATE
Shake.COOKIES
Shake.MINT
</pre> <p>Enumeration members are hashable, so they can be used in dictionaries and sets:</p> <pre data-language="python">&gt;&gt;&gt; apples = {}
&gt;&gt;&gt; apples[Color.RED] = 'red delicious'
&gt;&gt;&gt; apples[Color.GREEN] = 'granny smith'
&gt;&gt;&gt; apples == {Color.RED: 'red delicious', Color.GREEN: 'granny smith'}
True
</pre> <h2 id="programmatic-access-to-enumeration-members-and-their-attributes">
<span class="section-number">8.13.3. </span>Programmatic access to enumeration members and their attributes</h2> <p>Sometimes it’s useful to access members in enumerations programmatically (i.e. situations where <code>Color.RED</code> won’t do because the exact color is not known at program-writing time). <code>Enum</code> allows such access:</p> <pre data-language="python">&gt;&gt;&gt; Color(1)
&lt;Color.RED: 1&gt;
&gt;&gt;&gt; Color(3)
&lt;Color.BLUE: 3&gt;
</pre> <p>If you want to access enum members by <em>name</em>, use item access:</p> <pre data-language="python">&gt;&gt;&gt; Color['RED']
&lt;Color.RED: 1&gt;
&gt;&gt;&gt; Color['GREEN']
&lt;Color.GREEN: 2&gt;
</pre> <p>If you have an enum member and need its <code>name</code> or <code>value</code>:</p> <pre data-language="python">&gt;&gt;&gt; member = Color.RED
&gt;&gt;&gt; member.name
'RED'
&gt;&gt;&gt; member.value
1
</pre> <h2 id="duplicating-enum-members-and-values">
<span class="section-number">8.13.4. </span>Duplicating enum members and values</h2> <p>Having two enum members with the same name is invalid:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     SQUARE = 2
...     SQUARE = 3
...
Traceback (most recent call last):
...
TypeError: Attempted to reuse key: 'SQUARE'
</pre> <p>However, two enum members are allowed to have the same value. Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(Enum):
...     SQUARE = 2
...     DIAMOND = 1
...     CIRCLE = 3
...     ALIAS_FOR_SQUARE = 2
...
&gt;&gt;&gt; Shape.SQUARE
&lt;Shape.SQUARE: 2&gt;
&gt;&gt;&gt; Shape.ALIAS_FOR_SQUARE
&lt;Shape.SQUARE: 2&gt;
&gt;&gt;&gt; Shape(2)
&lt;Shape.SQUARE: 2&gt;
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Attempting to create a member with the same name as an already defined attribute (another member, a method, etc.) or attempting to create an attribute with the same name as a member is not allowed.</p> </div> <h2 id="ensuring-unique-enumeration-values">
<span class="section-number">8.13.5. </span>Ensuring unique enumeration values</h2> <p>By default, enumerations allow multiple names as aliases for the same value. When this behavior isn’t desired, the following decorator can be used to ensure each value is used only once in the enumeration:</p> <dl class="function"> <dt>
<code>@enum.unique</code> </dt>
</dl> <p>A <code>class</code> decorator specifically for enumerations. It searches an enumeration’s <code>__members__</code> gathering any aliases it finds; if any are found <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> is raised with the details:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum, unique
&gt;&gt;&gt; @unique
... class Mistake(Enum):
...     ONE = 1
...     TWO = 2
...     THREE = 3
...     FOUR = 3
...
Traceback (most recent call last):
...
ValueError: duplicate values found in &lt;enum 'Mistake'&gt;: FOUR -&gt; THREE
</pre> <h2 id="using-automatic-values">
<span class="section-number">8.13.6. </span>Using automatic values</h2> <p>If the exact value is unimportant you can use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Enum, auto
&gt;&gt;&gt; class Color(Enum):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</pre> <p>The values are chosen by <code>_generate_next_value_()</code>, which can be overridden:</p> <pre data-language="python">&gt;&gt;&gt; class AutoName(Enum):
...     def _generate_next_value_(name, start, count, last_values):
...         return name
...
&gt;&gt;&gt; class Ordinal(AutoName):
...     NORTH = auto()
...     SOUTH = auto()
...     EAST = auto()
...     WEST = auto()
...
&gt;&gt;&gt; list(Ordinal)
[&lt;Ordinal.NORTH: 'NORTH'&gt;, &lt;Ordinal.SOUTH: 'SOUTH'&gt;, &lt;Ordinal.EAST: 'EAST'&gt;, &lt;Ordinal.WEST: 'WEST'&gt;]
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The goal of the default <code>_generate_next_value_()</code> methods is to provide the next <a class="reference internal" href="functions#int" title="int"><code>int</code></a> in sequence with the last <a class="reference internal" href="functions#int" title="int"><code>int</code></a> provided, but the way it does this is an implementation detail and may change.</p> </div> <h2 id="iteration">
<span class="section-number">8.13.7. </span>Iteration</h2> <p>Iterating over the members of an enum does not provide the aliases:</p> <pre data-language="python">&gt;&gt;&gt; list(Shape)
[&lt;Shape.SQUARE: 2&gt;, &lt;Shape.DIAMOND: 1&gt;, &lt;Shape.CIRCLE: 3&gt;]
</pre> <p>The special attribute <code>__members__</code> is an ordered dictionary mapping names to members. It includes all names defined in the enumeration, including the aliases:</p> <pre data-language="python">&gt;&gt;&gt; for name, member in Shape.__members__.items():
...     name, member
...
('SQUARE', &lt;Shape.SQUARE: 2&gt;)
('DIAMOND', &lt;Shape.DIAMOND: 1&gt;)
('CIRCLE', &lt;Shape.CIRCLE: 3&gt;)
('ALIAS_FOR_SQUARE', &lt;Shape.SQUARE: 2&gt;)
</pre> <p>The <code>__members__</code> attribute can be used for detailed programmatic access to the enumeration members. For example, finding all the aliases:</p> <pre data-language="python">&gt;&gt;&gt; [name for name, member in Shape.__members__.items() if member.name != name]
['ALIAS_FOR_SQUARE']
</pre> <h2 id="comparisons">
<span class="section-number">8.13.8. </span>Comparisons</h2> <p>Enumeration members are compared by identity:</p> <pre data-language="python">&gt;&gt;&gt; Color.RED is Color.RED
True
&gt;&gt;&gt; Color.RED is Color.BLUE
False
&gt;&gt;&gt; Color.RED is not Color.BLUE
True
</pre> <p>Ordered comparisons between enumeration values are <em>not</em> supported. Enum members are not integers (but see <a class="reference internal" href="#intenum">IntEnum</a> below):</p> <pre data-language="python">&gt;&gt;&gt; Color.RED &lt; Color.BLUE
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'Color' and 'Color'
</pre> <p>Equality comparisons are defined though:</p> <pre data-language="python">&gt;&gt;&gt; Color.BLUE == Color.RED
False
&gt;&gt;&gt; Color.BLUE != Color.RED
True
&gt;&gt;&gt; Color.BLUE == Color.BLUE
True
</pre> <p>Comparisons against non-enumeration values will always compare not equal (again, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> was explicitly designed to behave differently, see below):</p> <pre data-language="python">&gt;&gt;&gt; Color.BLUE == 2
False
</pre> <h2 id="allowed-members-and-attributes-of-enumerations">
<span class="section-number">8.13.9. </span>Allowed members and attributes of enumerations</h2> <p>The examples above use integers for enumeration values. Using integers is short and handy (and provided by default by the <a class="reference internal" href="#functional-api">Functional API</a>), but not strictly enforced. In the vast majority of use-cases, one doesn’t care what the actual value of an enumeration is. But if the value <em>is</em> important, enumerations can have arbitrary values.</p> <p>Enumerations are Python classes, and can have methods and special methods as usual. If we have this enumeration:</p> <pre data-language="python">&gt;&gt;&gt; class Mood(Enum):
...     FUNKY = 1
...     HAPPY = 3
...
...     def describe(self):
...         # self is the member here
...         return self.name, self.value
...
...     def __str__(self):
...         return 'my custom str! {0}'.format(self.value)
...
...     @classmethod
...     def favorite_mood(cls):
...         # cls here is the enumeration
...         return cls.HAPPY
...
</pre> <p>Then:</p> <pre data-language="python">&gt;&gt;&gt; Mood.favorite_mood()
&lt;Mood.HAPPY: 3&gt;
&gt;&gt;&gt; Mood.HAPPY.describe()
('HAPPY', 3)
&gt;&gt;&gt; str(Mood.FUNKY)
'my custom str! 1'
</pre> <p>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (<code>__str__()</code>, <code>__add__()</code>, etc.) and descriptors (methods are also descriptors).</p> <p>Note: if your enumeration defines <code>__new__()</code> and/or <code>__init__()</code> then whatever value(s) were given to the enum member will be passed into those methods. See <a class="reference internal" href="#planet">Planet</a> for an example.</p> <h2 id="restricted-subclassing-of-enumerations">
<span class="section-number">8.13.10. </span>Restricted subclassing of enumerations</h2> <p>Subclassing an enumeration is allowed only if the enumeration does not define any members. So this is forbidden:</p> <pre data-language="python">&gt;&gt;&gt; class MoreColor(Color):
...     PINK = 17
...
Traceback (most recent call last):
...
TypeError: Cannot extend enumerations
</pre> <p>But this is allowed:</p> <pre data-language="python">&gt;&gt;&gt; class Foo(Enum):
...     def some_behavior(self):
...         pass
...
&gt;&gt;&gt; class Bar(Foo):
...     HAPPY = 1
...     SAD = 2
...
</pre> <p>Allowing subclassing of enums that define members would lead to a violation of some important invariants of types and instances. On the other hand, it makes sense to allow sharing some common behavior between a group of enumerations. (See <a class="reference internal" href="#orderedenum">OrderedEnum</a> for an example.)</p> <h2 id="pickling">
<span class="section-number">8.13.11. </span>Pickling</h2> <p>Enumerations can be pickled and unpickled:</p> <pre data-language="python">&gt;&gt;&gt; from test.test_enum import Fruit
&gt;&gt;&gt; from pickle import dumps, loads
&gt;&gt;&gt; Fruit.TOMATO is loads(dumps(Fruit.TOMATO))
True
</pre> <p>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</p> </div> <p>It is possible to modify how Enum members are pickled/unpickled by defining <a class="reference internal" href="pickle#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> in the enumeration class.</p> <h2 id="functional-api">
<span class="section-number">8.13.12. </span>Functional API</h2> <p>The <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class is callable, providing the following functional API:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG')
&gt;&gt;&gt; Animal
&lt;enum 'Animal'&gt;
&gt;&gt;&gt; Animal.ANT
&lt;Animal.ANT: 1&gt;
&gt;&gt;&gt; Animal.ANT.value
1
&gt;&gt;&gt; list(Animal)
[&lt;Animal.ANT: 1&gt;, &lt;Animal.BEE: 2&gt;, &lt;Animal.CAT: 3&gt;, &lt;Animal.DOG: 4&gt;]
</pre> <p>The semantics of this API resemble <a class="reference internal" href="collections#collections.namedtuple" title="collections.namedtuple"><code>namedtuple</code></a>. The first argument of the call to <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is the name of the enumeration.</p> <p>The second argument is the <em>source</em> of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the <code>start</code> parameter to specify a different starting value). A new class derived from <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is returned. In other words, the above assignment to <code>Animal</code> is equivalent to:</p> <pre data-language="python">&gt;&gt;&gt; class Animal(Enum):
...     ANT = 1
...     BEE = 2
...     CAT = 3
...     DOG = 4
...
</pre> <p>The reason for defaulting to <code>1</code> as the starting number and not <code>0</code> is that <code>0</code> is <code>False</code> in a boolean sense, but enum members all evaluate to <code>True</code>.</p> <p>Pickling enums created with the functional API can be tricky as frame stack implementation details are used to try and figure out which module the enumeration is being created in (e.g. it will fail if you use a utility function in separate module, and also may not work on IronPython or Jython). The solution is to specify the module name explicitly as follows:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If <code>module</code> is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled.</p> </div> <p>The new pickle protocol 4 also, in some circumstances, relies on <a class="reference internal" href="stdtypes#definition.__qualname__" title="definition.__qualname__"><code>__qualname__</code></a> being set to the location where pickle will be able to find the class. For example, if the class was made available in class SomeData in the global scope:</p> <pre data-language="python">&gt;&gt;&gt; Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')
</pre> <p>The complete signature is:</p> <pre data-language="python">Enum(value='NewEnumName', names=&lt;...&gt;, *, module='...', qualname='...', type=&lt;mixed-in class&gt;, start=1)
</pre> <dl class="field-list"> <dt class="field-odd">value</dt> <dd class="field-odd">
<p>What the new Enum class will record as its name.</p> </dd> <dt class="field-even">names</dt> <dd class="field-even">
<p>The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified):</p> <pre data-language="python">'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'
</pre> <p>or an iterator of names:</p> <pre data-language="python">['RED', 'GREEN', 'BLUE']
</pre> <p>or an iterator of (name, value) pairs:</p> <pre data-language="python">[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]
</pre> <p>or a mapping:</p> <pre data-language="python">{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}
</pre> </dd> <dt class="field-odd">module</dt> <dd class="field-odd">
<p>name of module where new Enum class can be found.</p> </dd> <dt class="field-even">qualname</dt> <dd class="field-even">
<p>where in module new Enum class can be found.</p> </dd> <dt class="field-odd">type</dt> <dd class="field-odd">
<p>type to mix in to new Enum class.</p> </dd> <dt class="field-even">start</dt> <dd class="field-even">
<p>number to start counting at if only names are passed in.</p> </dd> </dl> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>start</em> parameter was added.</p> </div> <h2 id="derived-enumerations">
<span class="section-number">8.13.13. </span>Derived Enumerations</h2> <h3 id="intenum">
<span class="section-number">8.13.13.1. </span>IntEnum</h3> <p>The first variation of <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> that is provided is also a subclass of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. Members of an <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> can be compared to integers; by extension, integer enumerations of different types can also be compared to each other:</p> <pre data-language="python">&gt;&gt;&gt; from enum import IntEnum
&gt;&gt;&gt; class Shape(IntEnum):
...     CIRCLE = 1
...     SQUARE = 2
...
&gt;&gt;&gt; class Request(IntEnum):
...     POST = 1
...     GET = 2
...
&gt;&gt;&gt; Shape == 1
False
&gt;&gt;&gt; Shape.CIRCLE == 1
True
&gt;&gt;&gt; Shape.CIRCLE == Request.POST
True
</pre> <p>However, they still can’t be compared to standard <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> enumerations:</p> <pre data-language="python">&gt;&gt;&gt; class Shape(IntEnum):
...     CIRCLE = 1
...     SQUARE = 2
...
&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     GREEN = 2
...
&gt;&gt;&gt; Shape.CIRCLE == Color.RED
False
</pre> <p><a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> values behave like integers in other ways you’d expect:</p> <pre data-language="python">&gt;&gt;&gt; int(Shape.CIRCLE)
1
&gt;&gt;&gt; ['a', 'b', 'c'][Shape.CIRCLE]
'b'
&gt;&gt;&gt; [i for i in range(Shape.SQUARE)]
[0, 1]
</pre> <h3 id="intflag">
<span class="section-number">8.13.13.2. </span>IntFlag</h3> <p>The next variation of <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> provided, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, is also based on <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. The difference being <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members can be combined using the bitwise operators (&amp;, |, ^, ~) and the result is still an <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> member. However, as the name implies, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members also subclass <a class="reference internal" href="functions#int" title="int"><code>int</code></a> and can be used wherever an <a class="reference internal" href="functions#int" title="int"><code>int</code></a> is used. Any operation on an <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> member besides the bit-wise operations will lose the <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> membership.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> <p>Sample <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> class:</p> <pre data-language="python">&gt;&gt;&gt; from enum import IntFlag
&gt;&gt;&gt; class Perm(IntFlag):
...     R = 4
...     W = 2
...     X = 1
...
&gt;&gt;&gt; Perm.R | Perm.W
&lt;Perm.R|W: 6&gt;
&gt;&gt;&gt; Perm.R + Perm.W
6
&gt;&gt;&gt; RW = Perm.R | Perm.W
&gt;&gt;&gt; Perm.R in RW
True
</pre> <p>It is also possible to name the combinations:</p> <pre data-language="python">&gt;&gt;&gt; class Perm(IntFlag):
...     R = 4
...     W = 2
...     X = 1
...     RWX = 7
&gt;&gt;&gt; Perm.RWX
&lt;Perm.RWX: 7&gt;
&gt;&gt;&gt; ~Perm.RWX
&lt;Perm.-8: -8&gt;
</pre> <p>Another important difference between <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> and <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> is that if no flags are set (the value is 0), its boolean evaluation is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; Perm.R &amp; Perm.X
&lt;Perm.0: 0&gt;
&gt;&gt;&gt; bool(Perm.R &amp; Perm.X)
False
</pre> <p>Because <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> members are also subclasses of <a class="reference internal" href="functions#int" title="int"><code>int</code></a> they can be combined with them:</p> <pre data-language="python">&gt;&gt;&gt; Perm.X | 8
&lt;Perm.8|X: 9&gt;
</pre> <h3 id="flag">
<span class="section-number">8.13.13.3. </span>Flag</h3> <p>The last variation is <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a>. Like <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> members can be combined using the bitwise operators (&amp;, |, ^, ~). Unlike <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, they cannot be combined with, nor compared against, any other <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> enumeration, nor <a class="reference internal" href="functions#int" title="int"><code>int</code></a>. While it is possible to specify the values directly it is recommended to use <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> as the value and let <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> select an appropriate value.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> <p>Like <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, if a combination of <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> members results in no flags being set, the boolean evaluation is <a class="reference internal" href="constants#False" title="False"><code>False</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; from enum import Flag, auto
&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.RED &amp; Color.GREEN
&lt;Color.0: 0&gt;
&gt;&gt;&gt; bool(Color.RED &amp; Color.GREEN)
False
</pre> <p>Individual flags should have values that are powers of two (1, 2, 4, 8, …), while combinations of flags won’t:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...     WHITE = RED | BLUE | GREEN
...
&gt;&gt;&gt; Color.WHITE
&lt;Color.WHITE: 7&gt;
</pre> <p>Giving a name to the “no flags set” condition does not change its boolean value:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     BLACK = 0
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.BLACK
&lt;Color.BLACK: 0&gt;
&gt;&gt;&gt; bool(Color.BLACK)
False
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For the majority of new code, <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> are strongly recommended, since <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> break some semantic promises of an enumeration (by being comparable to integers, and thus by transitivity to other unrelated enumerations). <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a> should be used only in cases where <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> will not do; for example, when integer constants are replaced with enumerations, or for interoperability with other systems.</p> </div> <h3 id="others">
<span class="section-number">8.13.13.4. </span>Others</h3> <p>While <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> is part of the <a class="reference internal" href="#module-enum" title="enum: Implementation of an enumeration class."><code>enum</code></a> module, it would be very simple to implement independently:</p> <pre data-language="python">class IntEnum(int, Enum):
    pass
</pre> <p>This demonstrates how similar derived enumerations can be defined; for example a <code>StrEnum</code> that mixes in <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a> instead of <a class="reference internal" href="functions#int" title="int"><code>int</code></a>.</p> <p>Some rules:</p> <ol class="arabic simple"> <li>When subclassing <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, mix-in types must appear before <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> itself in the sequence of bases, as in the <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> example above.</li> <li>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. <a class="reference internal" href="functions#int" title="int"><code>int</code></a> above. This restriction does not apply to mix-ins which only add methods and don’t specify another data type such as <a class="reference internal" href="functions#int" title="int"><code>int</code></a> or <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>.</li> <li>When another data type is mixed in, the <code>value</code> attribute is <em>not the same</em> as the enum member itself, although it is equivalent and will compare equal.</li> <li>%-style formatting: <code>%s</code> and <code>%r</code> call the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <code>__str__()</code> and <code>__repr__()</code> respectively; other codes (such as <code>%i</code> or <code>%h</code> for IntEnum) treat the enum member as its mixed-in type.</li> <li>
<span class="std std-ref">Formatted string literals</span>, <a class="reference internal" href="stdtypes#str.format" title="str.format"><code>str.format()</code></a>, and <a class="reference internal" href="functions#format" title="format"><code>format()</code></a> will use the mixed-in type’s <code>__format__()</code>. If the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class’s <a class="reference internal" href="stdtypes#str" title="str"><code>str()</code></a> or <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> is desired, use the <code>!s</code> or <code>!r</code> format codes.</li> </ol> <h2 id="interesting-examples">
<span class="section-number">8.13.14. </span>Interesting examples</h2> <p>While <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a>, <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a>, <a class="reference internal" href="#enum.IntFlag" title="enum.IntFlag"><code>IntFlag</code></a>, and <a class="reference internal" href="#enum.Flag" title="enum.Flag"><code>Flag</code></a> are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one’s own.</p> <h3 id="omitting-values">
<span class="section-number">8.13.14.1. </span>Omitting values</h3> <p>In many use-cases one doesn’t care what the actual value of an enumeration is. There are several ways to define this type of simple enumeration:</p> <ul class="simple"> <li>use instances of <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> for the value</li> <li>use instances of <a class="reference internal" href="functions#object" title="object"><code>object</code></a> as the value</li> <li>use a descriptive string as the value</li> <li>use a tuple as the value and a custom <code>__new__()</code> to replace the tuple with an <a class="reference internal" href="functions#int" title="int"><code>int</code></a> value</li> </ul> <p>Using any of these methods signifies to the user that these values are not important, and also enables one to add, remove, or reorder members without having to renumber the remaining members.</p> <p>Whichever method you choose, you should provide a <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> that also hides the (unimportant) value:</p> <pre data-language="python">&gt;&gt;&gt; class NoValue(Enum):
...     def __repr__(self):
...         return '&lt;%s.%s&gt;' % (self.__class__.__name__, self.name)
...
</pre> <h4 id="using-auto">
<span class="section-number">8.13.14.1.1. </span>Using <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a>
</h4> <p>Using <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = auto()
...     BLUE = auto()
...     GREEN = auto()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
</pre> <h4 id="using-object">
<span class="section-number">8.13.14.1.2. </span>Using <a class="reference internal" href="functions#object" title="object"><code>object</code></a>
</h4> <p>Using <a class="reference internal" href="functions#object" title="object"><code>object</code></a> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = object()
...     GREEN = object()
...     BLUE = object()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
</pre> <h4 id="using-a-descriptive-string">
<span class="section-number">8.13.14.1.3. </span>Using a descriptive string</h4> <p>Using a string as the value would look like:</p> <pre data-language="python">&gt;&gt;&gt; class Color(NoValue):
...     RED = 'stop'
...     GREEN = 'go'
...     BLUE = 'too fast!'
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
&gt;&gt;&gt; Color.GREEN.value
'go'
</pre> <h4 id="using-a-custom-new">
<span class="section-number">8.13.14.1.4. </span>Using a custom <code>__new__()</code>
</h4> <p>Using an auto-numbering <code>__new__()</code> would look like:</p> <pre data-language="python">&gt;&gt;&gt; class AutoNumber(NoValue):
...     def __new__(cls):
...         value = len(cls.__members__) + 1
...         obj = object.__new__(cls)
...         obj._value_ = value
...         return obj
...
&gt;&gt;&gt; class Color(AutoNumber):
...     RED = ()
...     GREEN = ()
...     BLUE = ()
...
&gt;&gt;&gt; Color.GREEN
&lt;Color.GREEN&gt;
&gt;&gt;&gt; Color.GREEN.value
2
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>__new__()</code> method, if defined, is used during creation of the Enum members; it is then replaced by Enum’s <code>__new__()</code> which is used after class creation for lookup of existing members.</p> </div> <h3 id="orderedenum">
<span class="section-number">8.13.14.2. </span>OrderedEnum</h3> <p>An ordered enumeration that is not based on <a class="reference internal" href="#enum.IntEnum" title="enum.IntEnum"><code>IntEnum</code></a> and so maintains the normal <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> invariants (such as not being comparable to other enumerations):</p> <pre data-language="python">&gt;&gt;&gt; class OrderedEnum(Enum):
...     def __ge__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt;= other.value
...         return NotImplemented
...     def __gt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &gt; other.value
...         return NotImplemented
...     def __le__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt;= other.value
...         return NotImplemented
...     def __lt__(self, other):
...         if self.__class__ is other.__class__:
...             return self.value &lt; other.value
...         return NotImplemented
...
&gt;&gt;&gt; class Grade(OrderedEnum):
...     A = 5
...     B = 4
...     C = 3
...     D = 2
...     F = 1
...
&gt;&gt;&gt; Grade.C &lt; Grade.A
True
</pre> <h3 id="duplicatefreeenum">
<span class="section-number">8.13.14.3. </span>DuplicateFreeEnum</h3> <p>Raises an error if a duplicate member name is found instead of creating an alias:</p> <pre data-language="python">&gt;&gt;&gt; class DuplicateFreeEnum(Enum):
...     def __init__(self, *args):
...         cls = self.__class__
...         if any(self.value == e.value for e in cls):
...             a = self.name
...             e = cls(self.value).name
...             raise ValueError(
...                 "aliases not allowed in DuplicateFreeEnum:  %r --&gt; %r"
...                 % (a, e))
...
&gt;&gt;&gt; class Color(DuplicateFreeEnum):
...     RED = 1
...     GREEN = 2
...     BLUE = 3
...     GRENE = 2
...
Traceback (most recent call last):
...
ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --&gt; 'GREEN'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a useful example for subclassing Enum to add or change other behaviors as well as disallowing aliases. If the only desired change is disallowing aliases, the <a class="reference internal" href="#enum.unique" title="enum.unique"><code>unique()</code></a> decorator can be used instead.</p> </div> <h3 id="planet">
<span class="section-number">8.13.14.4. </span>Planet</h3> <p>If <code>__new__()</code> or <code>__init__()</code> is defined the value of the enum member will be passed to those methods:</p> <pre data-language="python">&gt;&gt;&gt; class Planet(Enum):
...     MERCURY = (3.303e+23, 2.4397e6)
...     VENUS   = (4.869e+24, 6.0518e6)
...     EARTH   = (5.976e+24, 6.37814e6)
...     MARS    = (6.421e+23, 3.3972e6)
...     JUPITER = (1.9e+27,   7.1492e7)
...     SATURN  = (5.688e+26, 6.0268e7)
...     URANUS  = (8.686e+25, 2.5559e7)
...     NEPTUNE = (1.024e+26, 2.4746e7)
...     def __init__(self, mass, radius):
...         self.mass = mass       # in kilograms
...         self.radius = radius   # in meters
...     @property
...     def surface_gravity(self):
...         # universal gravitational constant  (m3 kg-1 s-2)
...         G = 6.67300E-11
...         return G * self.mass / (self.radius * self.radius)
...
&gt;&gt;&gt; Planet.EARTH.value
(5.976e+24, 6378140.0)
&gt;&gt;&gt; Planet.EARTH.surface_gravity
9.802652743337129
</pre> <h2 id="how-are-enums-different">
<span class="section-number">8.13.15. </span>How are Enums different?</h2> <p>Enums have a custom metaclass that affects many aspects of both derived Enum classes and their instances (members).</p> <h3 id="enum-classes">
<span class="section-number">8.13.15.1. </span>Enum Classes</h3> <p>The <code>EnumMeta</code> metaclass is responsible for providing the <code>__contains__()</code>, <code>__dir__()</code>, <code>__iter__()</code> and other methods that allow one to do things with an <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class that fail on a typical class, such as <code>list(Color)</code> or <code>some_var in Color</code>. <code>EnumMeta</code> is responsible for ensuring that various other methods on the final <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class are correct (such as <code>__new__()</code>, <a class="reference internal" href="pickle#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a>, <code>__str__()</code> and <code>__repr__()</code>).</p> <h3 id="enum-members-aka-instances">
<span class="section-number">8.13.15.2. </span>Enum Members (aka instances)</h3> <p>The most interesting thing about Enum members is that they are singletons. <code>EnumMeta</code> creates them all while it is creating the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class itself, and then puts a custom <code>__new__()</code> in place to ensure that no new ones are ever instantiated by returning only the existing member instances.</p> <h3 id="finer-points">
<span class="section-number">8.13.15.3. </span>Finer Points</h3> <h4 id="supported-dunder-names">
<span class="section-number">8.13.15.3.1. </span>Supported <code>__dunder__</code> names</h4> <p><code>__members__</code> is an <code>OrderedDict</code> of <code>member_name</code>:<code>member</code> items. It is only available on the class.</p> <p><code>__new__()</code>, if specified, must create and return the enum members; it is also a very good idea to set the member’s <code>_value_</code> appropriately. Once all the members are created it is no longer used.</p> <h4 id="supported-sunder-names">
<span class="section-number">8.13.15.3.2. </span>Supported <code>_sunder_</code> names</h4> <ul class="simple"> <li>
<code>_name_</code> – name of the member</li> <li>
<code>_value_</code> – value of the member; can be set / modified in <code>__new__</code>
</li> <li>
<code>_missing_</code> – a lookup function used when a value is not found; may be overridden</li> <li>
<code>_order_</code> – used in Python 2/3 code to ensure member order is consistent (class attribute, removed during class creation)</li> <li>
<code>_generate_next_value_</code> – used by the <a class="reference internal" href="#functional-api">Functional API</a> and by <a class="reference internal" href="#enum.auto" title="enum.auto"><code>auto</code></a> to get an appropriate value for an enum member; may be overridden</li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span><code>_missing_</code>, <code>_order_</code>, <code>_generate_next_value_</code></p> </div> <p>To help keep Python 2 / Python 3 code in sync an <code>_order_</code> attribute can be provided. It will be checked against the actual order of the enumeration and raise an error if the two do not match:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Enum):
...     _order_ = 'RED GREEN BLUE'
...     RED = 1
...     BLUE = 3
...     GREEN = 2
...
Traceback (most recent call last):
...
TypeError: member order does not match _order_
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In Python 2 code the <code>_order_</code> attribute is necessary as definition order is lost before it can be recorded.</p> </div> <h4 id="enum-member-type">
<span class="section-number">8.13.15.3.3. </span><code>Enum</code> member type</h4> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members are instances of their <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> class, and are normally accessed as <code>EnumClass.member</code>. Under certain circumstances they can also be accessed as <code>EnumClass.member.member</code>, but you should never do this as that lookup may fail or, worse, return something besides the <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> member you are looking for (this is another good reason to use all-uppercase names for members):</p> <pre data-language="python">&gt;&gt;&gt; class FieldTypes(Enum):
...     name = 0
...     value = 1
...     size = 2
...
&gt;&gt;&gt; FieldTypes.value.size
&lt;FieldTypes.size: 2&gt;
&gt;&gt;&gt; FieldTypes.size.value
2
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.</span></p> </div> <h4 id="boolean-value-of-enum-classes-and-members">
<span class="section-number">8.13.15.3.4. </span>Boolean value of <code>Enum</code> classes and members</h4> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> members that are mixed with non-<a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> types (such as <a class="reference internal" href="functions#int" title="int"><code>int</code></a>, <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, etc.) are evaluated according to the mixed-in type’s rules; otherwise, all members evaluate as <a class="reference internal" href="constants#True" title="True"><code>True</code></a>. To make your own Enum’s boolean evaluation depend on the member’s value add the following to your class:</p> <pre data-language="python">def __bool__(self):
    return bool(self.value)
</pre> <p><a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> classes always evaluate as <a class="reference internal" href="constants#True" title="True"><code>True</code></a>.</p> <h4 id="enum-classes-with-methods">
<span class="section-number">8.13.15.3.5. </span><code>Enum</code> classes with methods</h4> <p>If you give your <a class="reference internal" href="#enum.Enum" title="enum.Enum"><code>Enum</code></a> subclass extra methods, like the <a class="reference internal" href="#planet">Planet</a> class above, those methods will show up in a <a class="reference internal" href="functions#dir" title="dir"><code>dir()</code></a> of the member, but not of the class:</p> <pre data-language="python">&gt;&gt;&gt; dir(Planet)
['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', 'VENUS', '__class__', '__doc__', '__members__', '__module__']
&gt;&gt;&gt; dir(Planet.EARTH)
['__class__', '__doc__', '__module__', 'name', 'surface_gravity', 'value']
</pre> <h4 id="combining-members-of-flag">
<span class="section-number">8.13.15.3.6. </span>Combining members of <code>Flag</code>
</h4> <p>If a combination of Flag members is not named, the <a class="reference internal" href="functions#repr" title="repr"><code>repr()</code></a> will include all named flags and all named combinations of flags that are in the value:</p> <pre data-language="python">&gt;&gt;&gt; class Color(Flag):
...     RED = auto()
...     GREEN = auto()
...     BLUE = auto()
...     MAGENTA = RED | BLUE
...     YELLOW = RED | GREEN
...     CYAN = GREEN | BLUE
...
&gt;&gt;&gt; Color(3)  # named combination
&lt;Color.YELLOW: 3&gt;
&gt;&gt;&gt; Color(7)      # not named combination
&lt;Color.CYAN|MAGENTA|BLUE|YELLOW|GREEN|RED: 7&gt;
</pre><div class="_attribution">
<p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br/>Licensed under the PSF License.<br/>
https://docs.python.org/3.6/library/enum.html
</p>
</div>
