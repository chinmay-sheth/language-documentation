<h1 id="collections-abc-abstract-base-classes-for-containers"> collections.abc â€” Abstract Base Classes for Containers</h1> <div class="versionadded" id="module-collections.abc"> <p><span class="versionmodified added">New in version 3.3: </span>Formerly, this module was part of the <a class="reference internal" href="collections#module-collections" title="collections: Container datatypes"><code>collections</code></a> module.</p> </div> <p><strong>Source code:</strong> Lib/_collections_abc.py</p> <p>This module provides <span class="xref std std-term">abstract base classes</span> that can be used to test whether a class provides a particular interface; for example, whether it is hashable or whether it is a mapping.</p> <h2 id="id1">
<span class="section-number">8.4.1. </span>Collections Abstract Base Classes</h2> <p id="collections-abstract-base-classes">The collections module offers the following <span class="xref std std-term">ABCs</span>:</p> <table class="docutils align-default"> <thead> <tr>
<th class="head"><p>ABC</p></th> <th class="head"><p>Inherits from</p></th> <th class="head"><p>Abstract Methods</p></th> <th class="head"><p>Mixin Methods</p></th> </tr> </thead> <tr>
<td><p><a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a></p></td> <td></td> <td><p><code>__contains__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable</code></a></p></td> <td></td> <td><p><code>__hash__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td></td> <td><p><code>__iter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__next__</code></p></td> <td><p><code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a></p></td> <td><p><code>__reversed__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Generator" title="collections.abc.Generator"><code>Generator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Iterator" title="collections.abc.Iterator"><code>Iterator</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code>, <code>__iter__</code>, <code>__next__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a></p></td> <td></td> <td><p><code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Callable" title="collections.abc.Callable"><code>Callable</code></a></p></td> <td></td> <td><p><code>__call__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a>, <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a>, <a class="reference internal" href="#collections.abc.Container" title="collections.abc.Container"><code>Container</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Reversible" title="collections.abc.Reversible"><code>Reversible</code></a>, <a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__reversed__</code>, <code>index</code>, and <code>count</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSequence" title="collections.abc.MutableSequence"><code>MutableSequence</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__len__</code>, <code>insert</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods and <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>, and <code>__iadd__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ByteString" title="collections.abc.ByteString"><code>ByteString</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a></p></td> <td><p><code>__getitem__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Sequence" title="collections.abc.Sequence"><code>Sequence</code></a> methods</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__le__</code>, <code>__lt__</code>, <code>__eq__</code>, <code>__ne__</code>, <code>__gt__</code>, <code>__ge__</code>, <code>__and__</code>, <code>__or__</code>, <code>__sub__</code>, <code>__xor__</code>, and <code>isdisjoint</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td><p><code>__contains__</code>, <code>__iter__</code>, <code>__len__</code>, <code>add</code>, <code>discard</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> methods and <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>__ior__</code>, <code>__iand__</code>, <code>__ixor__</code>, and <code>__isub__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Collection" title="collections.abc.Collection"><code>Collection</code></a></p></td> <td><p><code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p><code>__contains__</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>__eq__</code>, and <code>__ne__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MutableMapping" title="collections.abc.MutableMapping"><code>MutableMapping</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a></p></td> <td><p><code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, <code>__len__</code></p></td> <td><p>Inherited <a class="reference internal" href="#collections.abc.Mapping" title="collections.abc.Mapping"><code>Mapping</code></a> methods and <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>, and <code>setdefault</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Sized" title="collections.abc.Sized"><code>Sized</code></a></p></td> <td></td> <td><p><code>__len__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ItemsView" title="collections.abc.ItemsView"><code>ItemsView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.KeysView" title="collections.abc.KeysView"><code>KeysView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a>, <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.ValuesView" title="collections.abc.ValuesView"><code>ValuesView</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.MappingView" title="collections.abc.MappingView"><code>MappingView</code></a></p></td> <td></td> <td><p><code>__contains__</code>, <code>__iter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a></p></td> <td></td> <td><p><code>__await__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a></p></td> <td><p><code>send</code>, <code>throw</code></p></td> <td><p><code>close</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a></p></td> <td></td> <td><p><code>__aiter__</code></p></td> <td></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterable" title="collections.abc.AsyncIterable"><code>AsyncIterable</code></a></p></td> <td><p><code>__anext__</code></p></td> <td><p><code>__aiter__</code></p></td> </tr> <tr>
<td><p><a class="reference internal" href="#collections.abc.AsyncGenerator" title="collections.abc.AsyncGenerator"><code>AsyncGenerator</code></a></p></td> <td><p><a class="reference internal" href="#collections.abc.AsyncIterator" title="collections.abc.AsyncIterator"><code>AsyncIterator</code></a></p></td> <td><p><code>asend</code>, <code>athrow</code></p></td> <td><p><code>aclose</code>, <code>__aiter__</code>, <code>__anext__</code></p></td> </tr> </table> <dl class="class"> <dt id="collections.abc.Container">
<code>class collections.abc.Container</code> </dt> <dt id="collections.abc.Hashable">
<code>class collections.abc.Hashable</code> </dt> <dt id="collections.abc.Sized">
<code>class collections.abc.Sized</code> </dt> <dt id="collections.abc.Callable">
<code>class collections.abc.Callable</code> </dt> <dd>
<p>ABCs for classes that provide respectively the methods <code>__contains__()</code>, <code>__hash__()</code>, <code>__len__()</code>, and <code>__call__()</code>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Iterable">
<code>class collections.abc.Iterable</code> </dt> <dd>
<p>ABC for classes that provide the <code>__iter__()</code> method.</p> <p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as <a class="reference internal" href="#collections.abc.Iterable" title="collections.abc.Iterable"><code>Iterable</code></a> or that have an <code>__iter__()</code> method, but it does not detect classes that iterate with the <code>__getitem__()</code> method. The only reliable way to determine whether an object is <span class="xref std std-term">iterable</span> is to call <code>iter(obj)</code>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Collection">
<code>class collections.abc.Collection</code> </dt> <dd>
<p>ABC for sized iterable container classes.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Iterator">
<code>class collections.abc.Iterator</code> </dt> <dd>
<p>ABC for classes that provide the <a class="reference internal" href="stdtypes#iterator.__iter__" title="iterator.__iter__"><code>__iter__()</code></a> and <a class="reference internal" href="stdtypes#iterator.__next__" title="iterator.__next__"><code>__next__()</code></a> methods. See also the definition of <span class="xref std std-term">iterator</span>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Reversible">
<code>class collections.abc.Reversible</code> </dt> <dd>
<p>ABC for iterable classes that also provide the <code>__reversed__()</code> method.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Generator">
<code>class collections.abc.Generator</code> </dt> <dd>
<p>ABC for generator classes that implement the protocol defined in <strong>PEP 342</strong> that extends iterators with the <code>send()</code>, <code>throw()</code> and <code>close()</code> methods. See also the definition of <span class="xref std std-term">generator</span>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Sequence">
<code>class collections.abc.Sequence</code> </dt> <dt id="collections.abc.MutableSequence">
<code>class collections.abc.MutableSequence</code> </dt> <dt id="collections.abc.ByteString">
<code>class collections.abc.ByteString</code> </dt> <dd>
<p>ABCs for read-only and mutable <span class="xref std std-term">sequences</span>.</p> <p>Implementation note: Some of the mixin methods, such as <code>__iter__()</code>, <code>__reversed__()</code> and <code>index()</code>, make repeated calls to the underlying <code>__getitem__()</code> method. Consequently, if <code>__getitem__()</code> is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The index() method added support for <em>stop</em> and <em>start</em> arguments.</p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Set">
<code>class collections.abc.Set</code> </dt> <dt id="collections.abc.MutableSet">
<code>class collections.abc.MutableSet</code> </dt> <dd>
<p>ABCs for read-only and mutable sets.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Mapping">
<code>class collections.abc.Mapping</code> </dt> <dt id="collections.abc.MutableMapping">
<code>class collections.abc.MutableMapping</code> </dt> <dd>
<p>ABCs for read-only and mutable <span class="xref std std-term">mappings</span>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.MappingView">
<code>class collections.abc.MappingView</code> </dt> <dt id="collections.abc.ItemsView">
<code>class collections.abc.ItemsView</code> </dt> <dt id="collections.abc.KeysView">
<code>class collections.abc.KeysView</code> </dt> <dt id="collections.abc.ValuesView">
<code>class collections.abc.ValuesView</code> </dt> <dd>
<p>ABCs for mapping, items, keys, and values <span class="xref std std-term">views</span>.</p> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Awaitable">
<code>class collections.abc.Awaitable</code> </dt> <dd>
<p>ABC for <span class="xref std std-term">awaitable</span> objects, which can be used in <code>await</code> expressions. Custom implementations must provide the <code>__await__()</code> method.</p> <p><span class="xref std std-term">Coroutine</span> objects and instances of the <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> ABC are all instances of this ABC.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (generators decorated with <a class="reference internal" href="types#types.coroutine" title="types.coroutine"><code>types.coroutine()</code></a> or <a class="reference internal" href="asyncio-task#asyncio.coroutine" title="asyncio.coroutine"><code>asyncio.coroutine()</code></a>) are <em>awaitables</em>, even though they do not have an <code>__await__()</code> method. Using <code>isinstance(gencoro, Awaitable)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.Coroutine">
<code>class collections.abc.Coroutine</code> </dt> <dd>
<p>ABC for coroutine compatible classes. These implement the following methods, defined in <span class="std std-ref">Coroutine Objects</span>: <code>send()</code>, <code>throw()</code>, and <code>close()</code>. Custom implementations must also implement <code>__await__()</code>. All <a class="reference internal" href="#collections.abc.Coroutine" title="collections.abc.Coroutine"><code>Coroutine</code></a> instances are also instances of <a class="reference internal" href="#collections.abc.Awaitable" title="collections.abc.Awaitable"><code>Awaitable</code></a>. See also the definition of <span class="xref std std-term">coroutine</span>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In CPython, generator-based coroutines (generators decorated with <a class="reference internal" href="types#types.coroutine" title="types.coroutine"><code>types.coroutine()</code></a> or <a class="reference internal" href="asyncio-task#asyncio.coroutine" title="asyncio.coroutine"><code>asyncio.coroutine()</code></a>) are <em>awaitables</em>, even though they do not have an <code>__await__()</code> method. Using <code>isinstance(gencoro, Coroutine)</code> for them will return <code>False</code>. Use <a class="reference internal" href="inspect#inspect.isawaitable" title="inspect.isawaitable"><code>inspect.isawaitable()</code></a> to detect them.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncIterable">
<code>class collections.abc.AsyncIterable</code> </dt> <dd>
<p>ABC for classes that provide <code>__aiter__</code> method. See also the definition of <span class="xref std std-term">asynchronous iterable</span>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncIterator">
<code>class collections.abc.AsyncIterator</code> </dt> <dd>
<p>ABC for classes that provide <code>__aiter__</code> and <code>__anext__</code> methods. See also the definition of <span class="xref std std-term">asynchronous iterator</span>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="class"> <dt id="collections.abc.AsyncGenerator">
<code>class collections.abc.AsyncGenerator</code> </dt> <dd>
<p>ABC for asynchronous generator classes that implement the protocol defined in <strong>PEP 525</strong> and <strong>PEP 492</strong>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <p>These ABCs allow us to ask classes or instances if they provide particular functionality, for example:</p> <pre data-language="python">size = None
if isinstance(myvar, collections.abc.Sized):
    size = len(myvar)
</pre> <p>Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> API, it is only necessary to supply the three underlying abstract methods: <code>__contains__()</code>, <code>__iter__()</code>, and <code>__len__()</code>. The ABC supplies the remaining methods such as <code>__and__()</code> and <code>isdisjoint()</code>:</p> <pre data-language="python">class ListBasedSet(collections.abc.Set):
    ''' Alternate set implementation favoring space over speed
        and not requiring the set elements to be hashable. '''
    def __init__(self, iterable):
        self.elements = lst = []
        for value in iterable:
            if value not in lst:
                lst.append(value)

    def __iter__(self):
        return iter(self.elements)

    def __contains__(self, value):
        return value in self.elements

    def __len__(self):
        return len(self.elements)

s1 = ListBasedSet('abcdef')
s2 = ListBasedSet('defghi')
overlap = s1 &amp; s2            # The __and__() method is supported automatically
</pre> <p>Notes on using <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> and <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a> as a mixin:</p> <ol class="arabic simple"> <li>Since some set operations create new sets, the default mixin methods need a way to create new instances from an iterable. The class constructor is assumed to have a signature in the form <code>ClassName(iterable)</code>. That assumption is factored-out to an internal classmethod called <code>_from_iterable()</code> which calls <code>cls(iterable)</code> to produce a new set. If the <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin is being used in a class with a different constructor signature, you will need to override <code>_from_iterable()</code> with a classmethod that can construct new instances from an iterable argument.</li> <li>To override the comparisons (presumably for speed, as the semantics are fixed), redefine <code>__le__()</code> and <code>__ge__()</code>, then the other operations will automatically follow suit.</li> <li>The <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set</code></a> mixin provides a <code>_hash()</code> method to compute a hash value for the set; however, <code>__hash__()</code> is not defined because not all sets are hashable or immutable. To add set hashability using mixins, inherit from both <a class="reference internal" href="#collections.abc.Set" title="collections.abc.Set"><code>Set()</code></a> and <a class="reference internal" href="#collections.abc.Hashable" title="collections.abc.Hashable"><code>Hashable()</code></a>, then define <code>__hash__ = Set._hash</code>.</li> </ol> <div class="admonition seealso"> <p class="admonition-title">See also</p> <ul class="simple"> <li>
OrderedSet recipe for an example built on <a class="reference internal" href="#collections.abc.MutableSet" title="collections.abc.MutableSet"><code>MutableSet</code></a>.</li> <li>For more about ABCs, see the <a class="reference internal" href="abc#module-abc" title="abc: Abstract base classes according to PEP 3119."><code>abc</code></a> module and <strong>PEP 3119</strong>.</li> </ul> </div><div class="_attribution">
<p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br/>Licensed under the PSF License.<br/>
https://docs.python.org/3.6/library/collections.abc.html
</p>
</div>
