<h1 id="asyncio-event-loop"> Base Event Loop</h1> <p id="base-event-loop"><strong>Source code:</strong> Lib/asyncio/events.py</p> <p>The event loop is the central execution device provided by <a class="reference internal" href="asyncio#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a>. It provides multiple facilities, including:</p> <ul class="simple"> <li>Registering, executing and cancelling delayed calls (timeouts).</li> <li>Creating client and server <a class="reference internal" href="asyncio-protocol#asyncio-transport"><span class="std std-ref">transports</span></a> for various kinds of communication.</li> <li>Launching subprocesses and the associated <a class="reference internal" href="asyncio-protocol#asyncio-transport"><span class="std std-ref">transports</span></a> for communication with an external program.</li> <li>Delegating costly function calls to a pool of threads.</li> </ul> <dl class="class"> <dt id="asyncio.BaseEventLoop">
<code>class asyncio.BaseEventLoop</code> </dt> <dd>
<p>This class is an implementation detail. It is a subclass of <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code>AbstractEventLoop</code></a> and may be a base class of concrete event loop implementations found in <a class="reference internal" href="asyncio#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a>. It should not be used directly; use <a class="reference internal" href="#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code>AbstractEventLoop</code></a> instead. <code>BaseEventLoop</code> should not be subclassed by third-party code; the internal interface is not stable.</p> </dd>
</dl> <dl class="class"> <dt id="asyncio.AbstractEventLoop">
<code>class asyncio.AbstractEventLoop</code> </dt> <dd>
<p>Abstract base class of event loops.</p> <p>This class is <a class="reference internal" href="asyncio-dev#asyncio-multithreading"><span class="std std-ref">not thread safe</span></a>.</p> </dd>
</dl> <h2 id="run-an-event-loop">
<span class="section-number">18.5.1.1. </span>Run an event loop</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.run_forever">
<code>AbstractEventLoop.run_forever()</code> </dt> <dd>
<p>Run until <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code>stop()</code></a> is called. If <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code>stop()</code></a> is called before <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code>run_forever()</code></a> is called, this polls the I/O selector once with a timeout of zero, runs all callbacks scheduled in response to I/O events (and those that were already scheduled), and then exits. If <a class="reference internal" href="#asyncio.AbstractEventLoop.stop" title="asyncio.AbstractEventLoop.stop"><code>stop()</code></a> is called while <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code>run_forever()</code></a> is running, this will run the current batch of callbacks and then exit. Note that callbacks scheduled by callbacks will not run in that case; they will run the next time <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code>run_forever()</code></a> is called.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.1.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.run_until_complete">
<code>AbstractEventLoop.run_until_complete(future)</code> </dt> <dd>
<p>Run until the <a class="reference internal" href="asyncio-task#asyncio.Future" title="asyncio.Future"><code>Future</code></a> is done.</p> <p>If the argument is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine object</span></a>, it is wrapped by <a class="reference internal" href="asyncio-task#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a>.</p> <p>Return the Future’s result, or raise its exception.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.is_running">
<code>AbstractEventLoop.is_running()</code> </dt> <dd>
<p>Returns running status of event loop.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.stop">
<code>AbstractEventLoop.stop()</code> </dt> <dd>
<p>Stop running the event loop.</p> <p>This causes <a class="reference internal" href="#asyncio.AbstractEventLoop.run_forever" title="asyncio.AbstractEventLoop.run_forever"><code>run_forever()</code></a> to exit at the next suitable opportunity (see there for more details).</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.1.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.is_closed">
<code>AbstractEventLoop.is_closed()</code> </dt> <dd>
<p>Returns <code>True</code> if the event loop was closed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.close">
<code>AbstractEventLoop.close()</code> </dt> <dd>
<p>Close the event loop. The loop must not be running. Pending callbacks will be lost.</p> <p>This clears the queues and shuts down the executor, but does not wait for the executor to finish.</p> <p>This is idempotent and irreversible. No other methods should be called after this one.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.shutdown_asyncgens">
<code>coroutine AbstractEventLoop.shutdown_asyncgens()</code> </dt> <dd>
<p>Schedule all currently open <span class="xref std std-term">asynchronous generator</span> objects to close with an <code>aclose()</code> call. After calling this method, the event loop will issue a warning whenever a new asynchronous generator is iterated. Should be used to finalize all scheduled asynchronous generators reliably. Example:</p> <pre data-language="python">try:
    loop.run_forever()
finally:
    loop.run_until_complete(loop.shutdown_asyncgens())
    loop.close()
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <h2 id="asyncio-pass-keywords">
<span class="section-number">18.5.1.2. </span>Calls</h2> <p id="calls">Most <a class="reference internal" href="asyncio#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> functions don’t accept keywords. If you want to pass keywords to your callback, use <a class="reference internal" href="functools#functools.partial" title="functools.partial"><code>functools.partial()</code></a>. For example, <code>loop.call_soon(functools.partial(print, "Hello", flush=True))</code> will call <code>print("Hello", flush=True)</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="functools#functools.partial" title="functools.partial"><code>functools.partial()</code></a> is better than <code>lambda</code> functions, because <a class="reference internal" href="asyncio#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> can inspect <a class="reference internal" href="functools#functools.partial" title="functools.partial"><code>functools.partial()</code></a> object to display parameters in debug mode, whereas <code>lambda</code> functions have a poor representation.</p> </div> <dl class="method"> <dt id="asyncio.AbstractEventLoop.call_soon">
<code>AbstractEventLoop.call_soon(callback, *args)</code> </dt> <dd>
<p>Arrange for a callback to be called as soon as possible. The callback is called after <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>call_soon()</code></a> returns, when control returns to the event loop.</p> <p>This operates as a <abbr title="first-in, first-out">FIFO</abbr> queue, callbacks are called in the order in which they are registered. Each callback will be called exactly once.</p> <p>Any positional arguments after the callback will be passed to the callback when it is called.</p> <p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code>asyncio.Handle</code></a> is returned, which can be used to cancel the callback.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.call_soon_threadsafe">
<code>AbstractEventLoop.call_soon_threadsafe(callback, *args)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>call_soon()</code></a>, but thread safe.</p> <p>See the <a class="reference internal" href="asyncio-dev#asyncio-multithreading"><span class="std std-ref">concurrency and multithreading</span></a> section of the documentation.</p> </dd>
</dl> <h2 id="asyncio-delayed-calls">
<span class="section-number">18.5.1.3. </span>Delayed calls</h2> <p id="delayed-calls">The event loop has its own internal clock for computing timeouts. Which clock is used depends on the (platform-specific) event loop implementation; ideally it is a monotonic clock. This will generally be a different clock than <a class="reference internal" href="time#time.time" title="time.time"><code>time.time()</code></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Timeouts (relative <em>delay</em> or absolute <em>when</em>) should not exceed one day.</p> </div> <dl class="method"> <dt id="asyncio.AbstractEventLoop.call_later">
<code>AbstractEventLoop.call_later(delay, callback, *args)</code> </dt> <dd>
<p>Arrange for the <em>callback</em> to be called after the given <em>delay</em> seconds (either an int or float).</p> <p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code>asyncio.Handle</code></a> is returned, which can be used to cancel the callback.</p> <p><em>callback</em> will be called exactly once per call to <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>call_later()</code></a>. If two callbacks are scheduled for exactly the same time, it is undefined which will be called first.</p> <p>The optional positional <em>args</em> will be passed to the callback when it is called. If you want the callback to be called with some named arguments, use a closure or <a class="reference internal" href="functools#functools.partial" title="functools.partial"><code>functools.partial()</code></a>.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.call_at">
<code>AbstractEventLoop.call_at(when, callback, *args)</code> </dt> <dd>
<p>Arrange for the <em>callback</em> to be called at the given absolute timestamp <em>when</em> (an int or float), using the same time reference as <a class="reference internal" href="#asyncio.AbstractEventLoop.time" title="asyncio.AbstractEventLoop.time"><code>AbstractEventLoop.time()</code></a>.</p> <p>This method’s behavior is the same as <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>call_later()</code></a>.</p> <p>An instance of <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code>asyncio.Handle</code></a> is returned, which can be used to cancel the callback.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.time">
<code>AbstractEventLoop.time()</code> </dt> <dd>
<p>Return the current time, as a <a class="reference internal" href="functions#float" title="float"><code>float</code></a> value, according to the event loop’s internal clock.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-task#asyncio.sleep" title="asyncio.sleep"><code>asyncio.sleep()</code></a> function.</p> </div> <h2 id="futures">
<span class="section-number">18.5.1.4. </span>Futures</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_future">
<code>AbstractEventLoop.create_future()</code> </dt> <dd>
<p>Create an <a class="reference internal" href="asyncio-task#asyncio.Future" title="asyncio.Future"><code>asyncio.Future</code></a> object attached to the loop.</p> <p>This is a preferred way to create futures in asyncio, as event loop implementations can provide alternative implementations of the Future class (with better performance or instrumentation).</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.2.</span></p> </div> </dd>
</dl> <h2 id="tasks">
<span class="section-number">18.5.1.5. </span>Tasks</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_task">
<code>AbstractEventLoop.create_task(coro)</code> </dt> <dd>
<p>Schedule the execution of a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine object</span></a>: wrap it in a future. Return a <a class="reference internal" href="asyncio-task#asyncio.Task" title="asyncio.Task"><code>Task</code></a> object.</p> <p>Third-party event loops can use their own subclass of <a class="reference internal" href="asyncio-task#asyncio.Task" title="asyncio.Task"><code>Task</code></a> for interoperability. In this case, the result type is a subclass of <a class="reference internal" href="asyncio-task#asyncio.Task" title="asyncio.Task"><code>Task</code></a>.</p> <p>This method was added in Python 3.4.2. Use the <a class="reference internal" href="asyncio-task#asyncio.async" title="asyncio.async"><code>async()</code></a> function to support also older Python versions.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.set_task_factory">
<code>AbstractEventLoop.set_task_factory(factory)</code> </dt> <dd>
<p>Set a task factory that will be used by <a class="reference internal" href="#asyncio.AbstractEventLoop.create_task" title="asyncio.AbstractEventLoop.create_task"><code>AbstractEventLoop.create_task()</code></a>.</p> <p>If <em>factory</em> is <code>None</code> the default task factory will be set.</p> <p>If <em>factory</em> is a <em>callable</em>, it should have a signature matching <code>(loop, coro)</code>, where <em>loop</em> will be a reference to the active event loop, <em>coro</em> will be a coroutine object. The callable must return an <a class="reference internal" href="asyncio-task#asyncio.Future" title="asyncio.Future"><code>asyncio.Future</code></a> compatible object.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.4.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.get_task_factory">
<code>AbstractEventLoop.get_task_factory()</code> </dt> <dd>
<p>Return a task factory, or <code>None</code> if the default one is in use.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.4.</span></p> </div> </dd>
</dl> <h2 id="creating-connections">
<span class="section-number">18.5.1.6. </span>Creating connections</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_connection">
<code>coroutine AbstractEventLoop.create_connection(protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None)</code> </dt> <dd>
<p>Create a streaming transport connection to a given Internet <em>host</em> and <em>port</em>: socket family <a class="reference internal" href="socket#socket.AF_INET" title="socket.AF_INET"><code>AF_INET</code></a> or <a class="reference internal" href="socket#socket.AF_INET6" title="socket.AF_INET6"><code>AF_INET6</code></a> depending on <em>host</em> (or <em>family</em> if specified), socket type <a class="reference internal" href="socket#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code>SOCK_STREAM</code></a>. <em>protocol_factory</em> must be a callable returning a <a class="reference internal" href="asyncio-protocol#asyncio-protocol"><span class="std std-ref">protocol</span></a> instance.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a> which will try to establish the connection in the background. When successful, the coroutine returns a <code>(transport, protocol)</code> pair.</p> <p>The chronological synopsis of the underlying operation is as follows:</p> <ol class="arabic simple"> <li>The connection is established, and a <a class="reference internal" href="asyncio-protocol#asyncio-transport"><span class="std std-ref">transport</span></a> is created to represent it.</li> <li>
<em>protocol_factory</em> is called without arguments and must return a <a class="reference internal" href="asyncio-protocol#asyncio-protocol"><span class="std std-ref">protocol</span></a> instance.</li> <li>The protocol instance is tied to the transport, and its <code>connection_made()</code> method is called.</li> <li>The coroutine returns successfully with the <code>(transport, protocol)</code> pair.</li> </ol> <p>The created transport is an implementation-dependent bidirectional stream.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><em>protocol_factory</em> can be any kind of callable, not necessarily a class. For example, if you want to use a pre-created protocol instance, you can pass <code>lambda: my_protocol</code>.</p> </div> <p>Options that change how the connection is created:</p> <ul> <li>
<p><em>ssl</em>: if given and not false, a SSL/TLS transport is created (by default a plain TCP transport is created). If <em>ssl</em> is a <a class="reference internal" href="ssl#ssl.SSLContext" title="ssl.SSLContext"><code>ssl.SSLContext</code></a> object, this context is used to create the transport; if <em>ssl</em> is <a class="reference internal" href="constants#True" title="True"><code>True</code></a>, a context with some unspecified default settings is used.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="ssl#ssl-security"><span class="std std-ref">SSL/TLS security considerations</span></a></p> </div> </li> <li>
<em>server_hostname</em>, is only for use together with <em>ssl</em>, and sets or overrides the hostname that the target server’s certificate will be matched against. By default the value of the <em>host</em> argument is used. If <em>host</em> is empty, there is no default and you must pass a value for <em>server_hostname</em>. If <em>server_hostname</em> is an empty string, hostname matching is disabled (which is a serious security risk, allowing for man-in-the-middle-attacks).</li> <li>
<em>family</em>, <em>proto</em>, <em>flags</em> are the optional address family, protocol and flags to be passed through to getaddrinfo() for <em>host</em> resolution. If given, these should all be integers from the corresponding <a class="reference internal" href="socket#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> module constants.</li> <li>
<em>sock</em>, if given, should be an existing, already connected <a class="reference internal" href="socket#socket.socket" title="socket.socket"><code>socket.socket</code></a> object to be used by the transport. If <em>sock</em> is given, none of <em>host</em>, <em>port</em>, <em>family</em>, <em>proto</em>, <em>flags</em> and <em>local_addr</em> should be specified.</li> <li>
<em>local_addr</em>, if given, is a <code>(local_host, local_port)</code> tuple used to bind the socket to locally. The <em>local_host</em> and <em>local_port</em> are looked up using getaddrinfo(), similarly to <em>host</em> and <em>port</em>.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a>, SSL/TLS is now supported.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-stream#asyncio.open_connection" title="asyncio.open_connection"><code>open_connection()</code></a> function can be used to get a pair of (<a class="reference internal" href="asyncio-stream#asyncio.StreamReader" title="asyncio.StreamReader"><code>StreamReader</code></a>, <a class="reference internal" href="asyncio-stream#asyncio.StreamWriter" title="asyncio.StreamWriter"><code>StreamWriter</code></a>) instead of a protocol.</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_datagram_endpoint">
<code>coroutine AbstractEventLoop.create_datagram_endpoint(protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None)</code> </dt> <dd>
<div class="admonition note"> <p class="admonition-title">Note</p> <p>The parameter <em>reuse_address</em> is no longer supported, as using <code>SO_REUSEADDR</code> poses a significant security concern for UDP. Explicitly passing <code>reuse_address=True</code> will raise an exception.</p> <p>When multiple processes with differing UIDs assign sockets to an indentical UDP socket address with <code>SO_REUSEADDR</code>, incoming packets can become randomly distributed among the sockets.</p> <p>For supported platforms, <em>reuse_port</em> can be used as a replacement for similar functionality. With <em>reuse_port</em>, <code>SO_REUSEPORT</code> is used instead, which specifically prevents processes with differing UIDs from assigning sockets to the same socket address.</p> </div> <p>Create a datagram connection.</p> <p>Create datagram connection: socket family <a class="reference internal" href="socket#socket.AF_INET" title="socket.AF_INET"><code>AF_INET</code></a> or <a class="reference internal" href="socket#socket.AF_INET6" title="socket.AF_INET6"><code>AF_INET6</code></a> depending on <em>host</em> (or <em>family</em> if specified), socket type <a class="reference internal" href="socket#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code>SOCK_DGRAM</code></a>. <em>protocol_factory</em> must be a callable returning a <a class="reference internal" href="asyncio-protocol#asyncio-protocol"><span class="std std-ref">protocol</span></a> instance.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a> which will try to establish the connection in the background. When successful, the coroutine returns a <code>(transport, protocol)</code> pair.</p> <p>Options changing how the connection is created:</p> <ul class="simple"> <li>
<em>local_addr</em>, if given, is a <code>(local_host, local_port)</code> tuple used to bind the socket to locally. The <em>local_host</em> and <em>local_port</em> are looked up using <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code>getaddrinfo()</code></a>.</li> <li>
<em>remote_addr</em>, if given, is a <code>(remote_host, remote_port)</code> tuple used to connect the socket to a remote address. The <em>remote_host</em> and <em>remote_port</em> are looked up using <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code>getaddrinfo()</code></a>.</li> <li>
<em>family</em>, <em>proto</em>, <em>flags</em> are the optional address family, protocol and flags to be passed through to <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code>getaddrinfo()</code></a> for <em>host</em> resolution. If given, these should all be integers from the corresponding <a class="reference internal" href="socket#module-socket" title="socket: Low-level networking interface."><code>socket</code></a> module constants.</li> <li>
<em>reuse_port</em> tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are bound to, so long as they all set this flag when being created. This option is not supported on Windows and some UNIX’s. If the <code>SO_REUSEPORT</code> constant is not defined then this capability is unsupported.</li> <li>
<em>allow_broadcast</em> tells the kernel to allow this endpoint to send messages to the broadcast address.</li> <li>
<em>sock</em> can optionally be specified in order to use a preexisting, already connected, <a class="reference internal" href="socket#socket.socket" title="socket.socket"><code>socket.socket</code></a> object to be used by the transport. If specified, <em>local_addr</em> and <em>remote_addr</em> should be omitted (must be <a class="reference internal" href="constants#None" title="None"><code>None</code></a>).</li> </ul> <p>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a>, this method is not supported.</p> <p>See <a class="reference internal" href="asyncio-protocol#asyncio-udp-echo-client-protocol"><span class="std std-ref">UDP echo client protocol</span></a> and <a class="reference internal" href="asyncio-protocol#asyncio-udp-echo-server-protocol"><span class="std std-ref">UDP echo server protocol</span></a> examples.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.4.4: </span>The <em>family</em>, <em>proto</em>, <em>flags</em>, <em>reuse_address</em>, <em>reuse_port, *allow_broadcast</em>, and <em>sock</em> parameters were added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6.10: </span>The <em>reuse_address</em> parameter is no longer supporter due to security concerns</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_unix_connection">
<code>coroutine AbstractEventLoop.create_unix_connection(protocol_factory, path, *, ssl=None, sock=None, server_hostname=None)</code> </dt> <dd>
<p>Create UNIX connection: socket family <a class="reference internal" href="socket#socket.AF_UNIX" title="socket.AF_UNIX"><code>AF_UNIX</code></a>, socket type <a class="reference internal" href="socket#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code>SOCK_STREAM</code></a>. The <a class="reference internal" href="socket#socket.AF_UNIX" title="socket.AF_UNIX"><code>AF_UNIX</code></a> socket family is used to communicate between processes on the same machine efficiently.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a> which will try to establish the connection in the background. When successful, the coroutine returns a <code>(transport, protocol)</code> pair.</p> <p><em>path</em> is the name of a UNIX domain socket, and is required unless a <em>sock</em> parameter is specified. Abstract UNIX sockets, <a class="reference internal" href="stdtypes#str" title="str"><code>str</code></a>, and <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> paths are supported.</p> <p>See the <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code>AbstractEventLoop.create_connection()</code></a> method for parameters.</p> <p>Availability: UNIX.</p> </dd>
</dl> <h2 id="creating-listening-connections">
<span class="section-number">18.5.1.7. </span>Creating listening connections</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_server">
<code>coroutine AbstractEventLoop.create_server(protocol_factory, host=None, port=None, *, family=socket.AF_UNSPEC, flags=socket.AI_PASSIVE, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None)</code> </dt> <dd>
<p>Create a TCP server (socket type <a class="reference internal" href="socket#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code>SOCK_STREAM</code></a>) bound to <em>host</em> and <em>port</em>.</p> <p>Return a <a class="reference internal" href="#asyncio.Server" title="asyncio.Server"><code>Server</code></a> object, its <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code>sockets</code></a> attribute contains created sockets. Use the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code>Server.close()</code></a> method to stop the server: close listening sockets.</p> <p>Parameters:</p> <ul class="simple"> <li>The <em>host</em> parameter can be a string, in that case the TCP server is bound to <em>host</em> and <em>port</em>. The <em>host</em> parameter can also be a sequence of strings and in that case the TCP server is bound to all hosts of the sequence. If <em>host</em> is an empty string or <code>None</code>, all interfaces are assumed and a list of multiple sockets will be returned (most likely one for IPv4 and another one for IPv6).</li> <li>
<em>family</em> can be set to either <a class="reference internal" href="socket#socket.AF_INET" title="socket.AF_INET"><code>socket.AF_INET</code></a> or <a class="reference internal" href="socket#socket.AF_INET6" title="socket.AF_INET6"><code>AF_INET6</code></a> to force the socket to use IPv4 or IPv6. If not set it will be determined from host (defaults to <code>socket.AF_UNSPEC</code>).</li> <li>
<em>flags</em> is a bitmask for <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code>getaddrinfo()</code></a>.</li> <li>
<em>sock</em> can optionally be specified in order to use a preexisting socket object. If specified, <em>host</em> and <em>port</em> should be omitted (must be <a class="reference internal" href="constants#None" title="None"><code>None</code></a>).</li> <li>
<em>backlog</em> is the maximum number of queued connections passed to <a class="reference internal" href="socket#socket.socket.listen" title="socket.socket.listen"><code>listen()</code></a> (defaults to 100).</li> <li>
<em>ssl</em> can be set to an <a class="reference internal" href="ssl#ssl.SSLContext" title="ssl.SSLContext"><code>SSLContext</code></a> to enable SSL over the accepted connections.</li> <li>
<em>reuse_address</em> tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire. If not specified will automatically be set to <code>True</code> on UNIX.</li> <li>
<em>reuse_port</em> tells the kernel to allow this endpoint to be bound to the same port as other existing endpoints are bound to, so long as they all set this flag when being created. This option is not supported on Windows.</li> </ul> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a>, SSL/TLS is now supported.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The function <a class="reference internal" href="asyncio-stream#asyncio.start_server" title="asyncio.start_server"><code>start_server()</code></a> creates a (<a class="reference internal" href="asyncio-stream#asyncio.StreamReader" title="asyncio.StreamReader"><code>StreamReader</code></a>, <a class="reference internal" href="asyncio-stream#asyncio.StreamWriter" title="asyncio.StreamWriter"><code>StreamWriter</code></a>) pair and calls back a function with this pair.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.1: </span>The <em>host</em> parameter can now be a sequence of strings.</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.create_unix_server">
<code>coroutine AbstractEventLoop.create_unix_server(protocol_factory, path=None, *, sock=None, backlog=100, ssl=None)</code> </dt> <dd>
<p>Similar to <a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code>AbstractEventLoop.create_server()</code></a>, but specific to the socket family <a class="reference internal" href="socket#socket.AF_UNIX" title="socket.AF_UNIX"><code>AF_UNIX</code></a>.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> <p>Availability: UNIX.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseEventLoop.connect_accepted_socket">
<code>coroutine BaseEventLoop.connect_accepted_socket(protocol_factory, sock, *, ssl=None)</code> </dt> <dd>
<p>Handle an accepted connection.</p> <p>This is used by servers that accept connections outside of asyncio but that use asyncio to handle them.</p> <p>Parameters:</p> <ul class="simple"> <li>
<em>sock</em> is a preexisting socket object returned from an <code>accept</code> call.</li> <li>
<em>ssl</em> can be set to an <a class="reference internal" href="ssl#ssl.SSLContext" title="ssl.SSLContext"><code>SSLContext</code></a> to enable SSL over the accepted connections.</li> </ul> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>. When completed, the coroutine returns a <code>(transport, protocol)</code> pair.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.3.</span></p> </div> </dd>
</dl> <h2 id="watch-file-descriptors">
<span class="section-number">18.5.1.8. </span>Watch file descriptors</h2> <p>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a>, only socket handles are supported (ex: pipe file descriptors are not supported).</p> <p>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a>, these methods are not supported.</p> <dl class="method"> <dt id="asyncio.AbstractEventLoop.add_reader">
<code>AbstractEventLoop.add_reader(fd, callback, *args)</code> </dt> <dd>
<p>Start watching the file descriptor for read availability and then call the <em>callback</em> with specified arguments.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.remove_reader">
<code>AbstractEventLoop.remove_reader(fd)</code> </dt> <dd>
<p>Stop watching the file descriptor for read availability.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.add_writer">
<code>AbstractEventLoop.add_writer(fd, callback, *args)</code> </dt> <dd>
<p>Start watching the file descriptor for write availability and then call the <em>callback</em> with specified arguments.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.remove_writer">
<code>AbstractEventLoop.remove_writer(fd)</code> </dt> <dd>
<p>Stop watching the file descriptor for write availability.</p> </dd>
</dl> <p>The <a class="reference internal" href="#asyncio-watch-read-event"><span class="std std-ref">watch a file descriptor for read events</span></a> example uses the low-level <a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code>AbstractEventLoop.add_reader()</code></a> method to register the file descriptor of a socket.</p> <h2 id="low-level-socket-operations">
<span class="section-number">18.5.1.9. </span>Low-level socket operations</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.sock_recv">
<code>coroutine AbstractEventLoop.sock_recv(sock, nbytes)</code> </dt> <dd>
<p>Receive data from the socket. Modeled after blocking <a class="reference internal" href="socket#socket.socket.recv" title="socket.socket.recv"><code>socket.socket.recv()</code></a> method.</p> <p>The return value is a bytes object representing the data received. The maximum amount of data to be received at once is specified by <em>nbytes</em>.</p> <p>With <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop, the socket <em>sock</em> must be non-blocking.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.sock_sendall">
<code>coroutine AbstractEventLoop.sock_sendall(sock, data)</code> </dt> <dd>
<p>Send data to the socket. Modeled after blocking <a class="reference internal" href="socket#socket.socket.sendall" title="socket.socket.sendall"><code>socket.socket.sendall()</code></a> method.</p> <p>The socket must be connected to a remote socket. This method continues to send data from <em>data</em> until either all data has been sent or an error occurs. <code>None</code> is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully processed by the receiving end of the connection.</p> <p>With <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop, the socket <em>sock</em> must be non-blocking.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.sock_connect">
<code>coroutine AbstractEventLoop.sock_connect(sock, address)</code> </dt> <dd>
<p>Connect to a remote socket at <em>address</em>. Modeled after blocking <a class="reference internal" href="socket#socket.socket.connect" title="socket.socket.connect"><code>socket.socket.connect()</code></a> method.</p> <p>With <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop, the socket <em>sock</em> must be non-blocking.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.2: </span><code>address</code> no longer needs to be resolved. <code>sock_connect</code> will try to check if the <em>address</em> is already resolved by calling <a class="reference internal" href="socket#socket.inet_pton" title="socket.inet_pton"><code>socket.inet_pton()</code></a>. If not, <a class="reference internal" href="#asyncio.AbstractEventLoop.getaddrinfo" title="asyncio.AbstractEventLoop.getaddrinfo"><code>AbstractEventLoop.getaddrinfo()</code></a> will be used to resolve the <em>address</em>.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code>AbstractEventLoop.create_connection()</code></a> and <a class="reference internal" href="asyncio-stream#asyncio.open_connection" title="asyncio.open_connection"><code>asyncio.open_connection()</code></a>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.sock_accept">
<code>coroutine AbstractEventLoop.sock_accept(sock)</code> </dt> <dd>
<p>Accept a connection. Modeled after blocking <a class="reference internal" href="socket#socket.socket.accept" title="socket.socket.accept"><code>socket.socket.accept()</code></a>.</p> <p>The socket must be bound to an address and listening for connections. The return value is a pair <code>(conn, address)</code> where <em>conn</em> is a <em>new</em> socket object usable to send and receive data on the connection, and <em>address</em> is the address bound to the socket on the other end of the connection.</p> <p>The socket <em>sock</em> must be non-blocking.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code>AbstractEventLoop.create_server()</code></a> and <a class="reference internal" href="asyncio-stream#asyncio.start_server" title="asyncio.start_server"><code>start_server()</code></a>.</p> </div> </dd>
</dl> <h2 id="resolve-host-name">
<span class="section-number">18.5.1.10. </span>Resolve host name</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.getaddrinfo">
<code>coroutine AbstractEventLoop.getaddrinfo(host, port, *, family=0, type=0, proto=0, flags=0)</code> </dt> <dd>
<p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>, similar to <a class="reference internal" href="socket#socket.getaddrinfo" title="socket.getaddrinfo"><code>socket.getaddrinfo()</code></a> function but non-blocking.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.getnameinfo">
<code>coroutine AbstractEventLoop.getnameinfo(sockaddr, flags=0)</code> </dt> <dd>
<p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>, similar to <a class="reference internal" href="socket#socket.getnameinfo" title="socket.getnameinfo"><code>socket.getnameinfo()</code></a> function but non-blocking.</p> </dd>
</dl> <h2 id="connect-pipes">
<span class="section-number">18.5.1.11. </span>Connect pipes</h2> <p>On Windows with <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a>, these methods are not supported. Use <a class="reference internal" href="asyncio-eventloops#asyncio.ProactorEventLoop" title="asyncio.ProactorEventLoop"><code>ProactorEventLoop</code></a> to support pipes on Windows.</p> <dl class="method"> <dt id="asyncio.AbstractEventLoop.connect_read_pipe">
<code>coroutine AbstractEventLoop.connect_read_pipe(protocol_factory, pipe)</code> </dt> <dd>
<p>Register read pipe in eventloop.</p> <p><em>protocol_factory</em> should instantiate object with <a class="reference internal" href="asyncio-protocol#asyncio.Protocol" title="asyncio.Protocol"><code>Protocol</code></a> interface. <em>pipe</em> is a <span class="xref std std-term">file-like object</span>. Return pair <code>(transport, protocol)</code>, where <em>transport</em> supports the <a class="reference internal" href="asyncio-protocol#asyncio.ReadTransport" title="asyncio.ReadTransport"><code>ReadTransport</code></a> interface.</p> <p>With <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop, the <em>pipe</em> is set to non-blocking mode.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.connect_write_pipe">
<code>coroutine AbstractEventLoop.connect_write_pipe(protocol_factory, pipe)</code> </dt> <dd>
<p>Register write pipe in eventloop.</p> <p><em>protocol_factory</em> should instantiate object with <code>BaseProtocol</code> interface. <em>pipe</em> is <span class="xref std std-term">file-like object</span>. Return pair <code>(transport, protocol)</code>, where <em>transport</em> supports <a class="reference internal" href="asyncio-protocol#asyncio.WriteTransport" title="asyncio.WriteTransport"><code>WriteTransport</code></a> interface.</p> <p>With <a class="reference internal" href="asyncio-eventloops#asyncio.SelectorEventLoop" title="asyncio.SelectorEventLoop"><code>SelectorEventLoop</code></a> event loop, the <em>pipe</em> is set to non-blocking mode.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-subprocess#asyncio.AbstractEventLoop.subprocess_exec" title="asyncio.AbstractEventLoop.subprocess_exec"><code>AbstractEventLoop.subprocess_exec()</code></a> and <a class="reference internal" href="asyncio-subprocess#asyncio.AbstractEventLoop.subprocess_shell" title="asyncio.AbstractEventLoop.subprocess_shell"><code>AbstractEventLoop.subprocess_shell()</code></a> methods.</p> </div> <h2 id="unix-signals">
<span class="section-number">18.5.1.12. </span>UNIX signals</h2> <p>Availability: UNIX only.</p> <dl class="method"> <dt id="asyncio.AbstractEventLoop.add_signal_handler">
<code>AbstractEventLoop.add_signal_handler(signum, callback, *args)</code> </dt> <dd>
<p>Add a handler for a signal.</p> <p>Raise <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> if the signal number is invalid or uncatchable. Raise <a class="reference internal" href="exceptions#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> if there is a problem setting up the handler.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the callback</span></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.remove_signal_handler">
<code>AbstractEventLoop.remove_signal_handler(sig)</code> </dt> <dd>
<p>Remove a handler for a signal.</p> <p>Return <code>True</code> if a signal handler was removed, <code>False</code> if not.</p> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="signal#module-signal" title="signal: Set handlers for asynchronous events."><code>signal</code></a> module.</p> </div> <h2 id="executor">
<span class="section-number">18.5.1.13. </span>Executor</h2> <p>Call a function in an <a class="reference internal" href="concurrent.futures#concurrent.futures.Executor" title="concurrent.futures.Executor"><code>Executor</code></a> (pool of threads or pool of processes). By default, an event loop uses a thread pool executor (<a class="reference internal" href="concurrent.futures#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code>ThreadPoolExecutor</code></a>).</p> <dl class="method"> <dt id="asyncio.AbstractEventLoop.run_in_executor">
<code>coroutine AbstractEventLoop.run_in_executor(executor, func, *args)</code> </dt> <dd>
<p>Arrange for a <em>func</em> to be called in the specified executor.</p> <p>The <em>executor</em> argument should be an <a class="reference internal" href="concurrent.futures#concurrent.futures.Executor" title="concurrent.futures.Executor"><code>Executor</code></a> instance. The default executor is used if <em>executor</em> is <code>None</code>.</p> <p><a class="reference internal" href="#asyncio-pass-keywords"><span class="std std-ref">Use functools.partial to pass keywords to the *func*</span></a>.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5.3: </span><code>BaseEventLoop.run_in_executor()</code> no longer configures the <code>max_workers</code> of the thread pool executor it creates, instead leaving it up to the thread pool executor (<a class="reference internal" href="concurrent.futures#concurrent.futures.ThreadPoolExecutor" title="concurrent.futures.ThreadPoolExecutor"><code>ThreadPoolExecutor</code></a>) to set the default.</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.set_default_executor">
<code>AbstractEventLoop.set_default_executor(executor)</code> </dt> <dd>
<p>Set the default executor used by <a class="reference internal" href="#asyncio.AbstractEventLoop.run_in_executor" title="asyncio.AbstractEventLoop.run_in_executor"><code>run_in_executor()</code></a>.</p> </dd>
</dl> <h2 id="error-handling-api">
<span class="section-number">18.5.1.14. </span>Error Handling API</h2> <p>Allows customizing how exceptions are handled in the event loop.</p> <dl class="method"> <dt id="asyncio.AbstractEventLoop.set_exception_handler">
<code>AbstractEventLoop.set_exception_handler(handler)</code> </dt> <dd>
<p>Set <em>handler</em> as the new event loop exception handler.</p> <p>If <em>handler</em> is <code>None</code>, the default exception handler will be set.</p> <p>If <em>handler</em> is a callable object, it should have a matching signature to <code>(loop, context)</code>, where <code>loop</code> will be a reference to the active event loop, <code>context</code> will be a <code>dict</code> object (see <a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code>call_exception_handler()</code></a> documentation for details about context).</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.get_exception_handler">
<code>AbstractEventLoop.get_exception_handler()</code> </dt> <dd>
<p>Return the exception handler, or <code>None</code> if the default one is in use.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.default_exception_handler">
<code>AbstractEventLoop.default_exception_handler(context)</code> </dt> <dd>
<p>Default exception handler.</p> <p>This is called when an exception occurs and no exception handler is set, and can be called by a custom exception handler that wants to defer to the default behavior.</p> <p><em>context</em> parameter has the same meaning as in <a class="reference internal" href="#asyncio.AbstractEventLoop.call_exception_handler" title="asyncio.AbstractEventLoop.call_exception_handler"><code>call_exception_handler()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.call_exception_handler">
<code>AbstractEventLoop.call_exception_handler(context)</code> </dt> <dd>
<p>Call the current event loop exception handler.</p> <p><em>context</em> is a <code>dict</code> object containing the following keys (new keys may be introduced later):</p> <ul class="simple"> <li>‘message’: Error message;</li> <li>‘exception’ (optional): Exception object;</li> <li>‘future’ (optional): <a class="reference internal" href="asyncio-task#asyncio.Future" title="asyncio.Future"><code>asyncio.Future</code></a> instance;</li> <li>‘handle’ (optional): <a class="reference internal" href="#asyncio.Handle" title="asyncio.Handle"><code>asyncio.Handle</code></a> instance;</li> <li>‘protocol’ (optional): <a class="reference internal" href="asyncio-protocol#asyncio-protocol"><span class="std std-ref">Protocol</span></a> instance;</li> <li>‘transport’ (optional): <a class="reference internal" href="asyncio-protocol#asyncio-transport"><span class="std std-ref">Transport</span></a> instance;</li> <li>‘socket’ (optional): <a class="reference internal" href="socket#socket.socket" title="socket.socket"><code>socket.socket</code></a> instance.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Note: this method should not be overloaded in subclassed event loops. For any custom exception handling, use <a class="reference internal" href="#asyncio.AbstractEventLoop.set_exception_handler" title="asyncio.AbstractEventLoop.set_exception_handler"><code>set_exception_handler()</code></a> method.</p> </div> </dd>
</dl> <h2 id="debug-mode">
<span class="section-number">18.5.1.15. </span>Debug mode</h2> <dl class="method"> <dt id="asyncio.AbstractEventLoop.get_debug">
<code>AbstractEventLoop.get_debug()</code> </dt> <dd>
<p>Get the debug mode (<a class="reference internal" href="functions#bool" title="bool"><code>bool</code></a>) of the event loop.</p> <p>The default value is <code>True</code> if the environment variable <code>PYTHONASYNCIODEBUG</code> is set to a non-empty string, <code>False</code> otherwise.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.AbstractEventLoop.set_debug">
<code>AbstractEventLoop.set_debug(enabled: bool)</code> </dt> <dd>
<p>Set the debug mode of the event loop.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.4.2.</span></p> </div> </dd>
</dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-dev#asyncio-debug-mode"><span class="std std-ref">debug mode of asyncio</span></a>.</p> </div> <h2 id="server">
<span class="section-number">18.5.1.16. </span>Server</h2> <dl class="class"> <dt id="asyncio.Server">
<code>class asyncio.Server</code> </dt> <dd>
<p>Server listening on sockets.</p> <p>Object created by the <a class="reference internal" href="#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code>AbstractEventLoop.create_server()</code></a> method and the <a class="reference internal" href="asyncio-stream#asyncio.start_server" title="asyncio.start_server"><code>start_server()</code></a> function. Don’t instantiate the class directly.</p> <dl class="method"> <dt id="asyncio.Server.close">
<code>close()</code> </dt> <dd>
<p>Stop serving: close listening sockets and set the <a class="reference internal" href="#asyncio.Server.sockets" title="asyncio.Server.sockets"><code>sockets</code></a> attribute to <code>None</code>.</p> <p>The sockets that represent existing incoming client connections are left open.</p> <p>The server is closed asynchronously, use the <a class="reference internal" href="#asyncio.Server.wait_closed" title="asyncio.Server.wait_closed"><code>wait_closed()</code></a> coroutine to wait until the server is closed.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.Server.wait_closed">
<code>coroutine wait_closed()</code> </dt> <dd>
<p>Wait until the <a class="reference internal" href="#asyncio.Server.close" title="asyncio.Server.close"><code>close()</code></a> method completes.</p> <p>This method is a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </dd>
</dl> <dl class="attribute"> <dt id="asyncio.Server.sockets">
<code>sockets</code> </dt> <dd>
<p>List of <a class="reference internal" href="socket#socket.socket" title="socket.socket"><code>socket.socket</code></a> objects the server is listening to, or <code>None</code> if the server is closed.</p> </dd>
</dl> </dd>
</dl> <h2 id="handle">
<span class="section-number">18.5.1.17. </span>Handle</h2> <dl class="class"> <dt id="asyncio.Handle">
<code>class asyncio.Handle</code> </dt> <dd>
<p>A callback wrapper object returned by <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>AbstractEventLoop.call_soon()</code></a>, <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon_threadsafe" title="asyncio.AbstractEventLoop.call_soon_threadsafe"><code>AbstractEventLoop.call_soon_threadsafe()</code></a>, <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>AbstractEventLoop.call_later()</code></a>, and <a class="reference internal" href="#asyncio.AbstractEventLoop.call_at" title="asyncio.AbstractEventLoop.call_at"><code>AbstractEventLoop.call_at()</code></a>.</p> <dl class="method"> <dt id="asyncio.Handle.cancel">
<code>cancel()</code> </dt> <dd>
<p>Cancel the call. If the callback is already canceled or executed, this method has no effect.</p> </dd>
</dl> </dd>
</dl> <h2 id="event-loop-examples">
<span class="section-number">18.5.1.18. </span>Event loop examples</h2> <h3 id="asyncio-hello-world-callback">
<span class="section-number">18.5.1.18.1. </span>Hello World with call_soon()</h3> <p id="hello-world-with-call-soon">Example using the <a class="reference internal" href="#asyncio.AbstractEventLoop.call_soon" title="asyncio.AbstractEventLoop.call_soon"><code>AbstractEventLoop.call_soon()</code></a> method to schedule a callback. The callback displays <code>"Hello World"</code> and then stops the event loop:</p> <pre data-language="python">import asyncio

def hello_world(loop):
    print('Hello World')
    loop.stop()

loop = asyncio.get_event_loop()

# Schedule a call to hello_world()
loop.call_soon(hello_world, loop)

# Blocking call interrupted by loop.stop()
loop.run_forever()
loop.close()
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-task#asyncio-hello-world-coroutine"><span class="std std-ref">Hello World coroutine</span></a> example uses a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </div> <h3 id="asyncio-date-callback">
<span class="section-number">18.5.1.18.2. </span>Display the current date with call_later()</h3> <p id="display-the-current-date-with-call-later">Example of callback displaying the current date every second. The callback uses the <a class="reference internal" href="#asyncio.AbstractEventLoop.call_later" title="asyncio.AbstractEventLoop.call_later"><code>AbstractEventLoop.call_later()</code></a> method to reschedule itself during 5 seconds, and then stops the event loop:</p> <pre data-language="python">import asyncio
import datetime

def display_date(end_time, loop):
    print(datetime.datetime.now())
    if (loop.time() + 1.0) &lt; end_time:
        loop.call_later(1, display_date, end_time, loop)
    else:
        loop.stop()

loop = asyncio.get_event_loop()

# Schedule the first call to display_date()
end_time = loop.time() + 5.0
loop.call_soon(display_date, end_time, loop)

# Blocking call interrupted by loop.stop()
loop.run_forever()
loop.close()
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-task#asyncio-date-coroutine"><span class="std std-ref">coroutine displaying the current date</span></a> example uses a <a class="reference internal" href="asyncio-task#coroutine"><span class="std std-ref">coroutine</span></a>.</p> </div> <h3 id="asyncio-watch-read-event">
<span class="section-number">18.5.1.18.3. </span>Watch a file descriptor for read events</h3> <p id="watch-a-file-descriptor-for-read-events">Wait until a file descriptor received some data using the <a class="reference internal" href="#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code>AbstractEventLoop.add_reader()</code></a> method and then close the event loop:</p> <pre data-language="python">import asyncio
try:
    from socket import socketpair
except ImportError:
    from asyncio.windows_utils import socketpair

# Create a pair of connected file descriptors
rsock, wsock = socketpair()
loop = asyncio.get_event_loop()

def reader():
    data = rsock.recv(100)
    print("Received:", data.decode())
    # We are done: unregister the file descriptor
    loop.remove_reader(rsock)
    # Stop the event loop
    loop.stop()

# Register the file descriptor for read event
loop.add_reader(rsock, reader)

# Simulate the reception of data from the network
loop.call_soon(wsock.send, 'abc'.encode())

# Run the event loop
loop.run_forever()

# We are done, close sockets and the event loop
rsock.close()
wsock.close()
loop.close()
</pre> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>The <a class="reference internal" href="asyncio-protocol#asyncio-register-socket"><span class="std std-ref">register an open socket to wait for data using a protocol</span></a> example uses a low-level protocol created by the <a class="reference internal" href="#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code>AbstractEventLoop.create_connection()</code></a> method.</p> <p>The <a class="reference internal" href="asyncio-stream#asyncio-register-socket-streams"><span class="std std-ref">register an open socket to wait for data using streams</span></a> example uses high-level streams created by the <a class="reference internal" href="asyncio-stream#asyncio.open_connection" title="asyncio.open_connection"><code>open_connection()</code></a> function in a coroutine.</p> </div> <h3 id="set-signal-handlers-for-sigint-and-sigterm">
<span class="section-number">18.5.1.18.4. </span>Set signal handlers for SIGINT and SIGTERM</h3> <p>Register handlers for signals <code>SIGINT</code> and <code>SIGTERM</code> using the <a class="reference internal" href="#asyncio.AbstractEventLoop.add_signal_handler" title="asyncio.AbstractEventLoop.add_signal_handler"><code>AbstractEventLoop.add_signal_handler()</code></a> method:</p> <pre data-language="python">import asyncio
import functools
import os
import signal

def ask_exit(signame):
    print("got signal %s: exit" % signame)
    loop.stop()

loop = asyncio.get_event_loop()
for signame in ('SIGINT', 'SIGTERM'):
    loop.add_signal_handler(getattr(signal, signame),
                            functools.partial(ask_exit, signame))

print("Event loop running forever, press Ctrl+C to interrupt.")
print("pid %s: send SIGINT or SIGTERM to exit." % os.getpid())
try:
    loop.run_forever()
finally:
    loop.close()
</pre> <p>This example only works on UNIX.</p><div class="_attribution">
<p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br/>Licensed under the PSF License.<br/>
https://docs.python.org/3.6/library/asyncio-eventloop.html
</p>
</div>
