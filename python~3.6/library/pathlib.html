<h1 id="pathlib-object-oriented-filesystem-paths"> pathlib — Object-oriented filesystem paths</h1> <div class="versionadded" id="module-pathlib"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p><strong>Source code:</strong> Lib/pathlib.py</p> <p>This module offers classes representing filesystem paths with semantics appropriate for different operating systems. Path classes are divided between <a class="reference internal" href="#pure-paths"><span class="std std-ref">pure paths</span></a>, which provide purely computational operations without I/O, and <a class="reference internal" href="#concrete-paths"><span class="std std-ref">concrete paths</span></a>, which inherit from pure paths but also provide I/O operations.</p> <img alt="../_images/pathlib-inheritance.png" class="align-center" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAhoAAAHvCAMAAAAl0IYjAAAAq1BMVEVHcEwDAwMMDAwVFRUAAAAREREICAgAAAAAAAAZGRkAAAAAAAAAAAAAAAAEBAQAAAAAAAAGBgYAAAAAAAAAAAAAAAAAAAD///8AAAC/v78gICAFBQVeXl5/f39AQECgoKDf39/6+vrFxcUODg4VFRXt7e0rKytRUVE4ODjm5ubS0tKPj49FRUWurq7Z2dmampp2dnbz8/OmpqZubm5lZWWGhoa2trYcHBzLy8sNggMjAAAAF3RSTlMA4+vz3+/nf1/3n0Agv8/wUbIvCWZyjZf+QYgAABUGSURBVHja7N2Ldtq4Fgbgnk7OkCYtTdKm2pZ8v+MLGAyG93+ysyVDEpJM0sVlAj3/v9YQ1wjHkj9vyXSt6adPCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgCIIgZ5zhxdnmFlfvqPkszjZfcPVAAzRAAzRAAzRAAzRAAzRAAzRAAzRAAzQQ0EBAAwENBDRAAzRAAzRAAzRAAzRAAzRAAzRAAzRAAwENBDQQ0EBAAzRAAzRAAzRAAzRAAzRAAzRAAzRAAzQQ0EBAAwENBDRA41i5HHw9CRqB7wcHonE3uMZ1PUAGRMMHHTvTmHmcevpOq1C3mvnbO2vL/MiJ/EPQuBtcEF3iuh6GBj3o2JXG2ByE4vDtZrlppcqtnanbC3EPQMO4INDgXF/unVv6eXP1fa1j56oxWub+eBanL8yEepYIVtZI/ylpKfStnAreVVjjvonsaQiH/FU43YNG7+L71fWArnYbiz9oHrqhQ4RvsR83Q731a/e1hrnADXWKbL7I/CJsonlFlAeik3zsbNRffiFW5ImF4l15IoTXn4Ot34uJonpnGlf6ON+uHwrhDlHXf9BkcDvYN980DS1DXd192o/GSMbJgq/yytGXumv5mK2TJpaSpTcnd00jmJMlJlnpNeQI4TuRdBynMzTKiYyCnavG9S17u73efVi+/UET0eAAfRnQ/T0X4u9msbEHjchNleJ7XqvoX/z12qNSM8uyMgbBlz/PI8p4PqlbuzGtnkwo4bqs7LzW+PqLZ8bhz187DssANF4uQy9+/tjz4ZVpuPZKbNNw+rfW5dozNNyKfwbVZhrZWmvsS4Nnxvv/7L4MBY0XNL7d7P+9xuYCGxXBFg1XdZbO6PHKT6hNxOgIND71kyNoHKIv97zE2Psrr8CJYrs1TyGxrEtJaRgsMkptm6eYjtKym9hpKOqUsjkvK0RJbb1ISU70E200qRfS5geXNgn1y95feV3fgsbB+7IrjZF+4KDOFATeXBI5SWTmDF0SJmYzLYS7mUWmeotb6YddS7+b1g0vWgvz8mFflIPGkf8OxbdeXNwgtMJnxWD12GpqWf7+vxY0Tp/G+f71GmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmiABmj8n9L4+/PZZggaZ9yXXxhO9OXV3NFXDCf68lquaIDhRF9eyVdFQwwn+vLqydKJzyig8TH58Z2GJz6jgMbH5CcNb058RgGNj8kF3XDh+IrhRF+e5YYuTv4ZBTQ+JN/oXvsYYjjRl+3cEd1fXv487WcU0PiIXG3+5bsBhhN92cq9+VfvbgeDSwwn+nJ+ZwsaOFvQwNmCBs4WNEADwwkaOEHQwAmiL6CBvoAG+gIa6AtogAZogAbOFjRwtqCBswUN0MBwggZOEDRwgqCBE0RfQAN9AQ30BTQw2KABGjhb0MDZ/k6uB3cf98uHfx80n79//vtfy+0J0Bh+Odu8N3wX5/u/bBUXJ0Djy/kO31+gcVQaf53v8P0XNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADNEADND6GxsgLf79xMvPG507Dtzjv9SKxrDAQ475hI+uXLYpUNm8fIwj5F62mzw9sfszka8c8HI0ys217PgvebhXqVraT/MPbFtnbOzrTfrHdftY3aom8c6ehSEe+jaPiJmWim47+gYZfPR+452nML1LO1k5H9aOevzmQe9PIIpJSUfZ2q1lMseT//N+sGhPdPqJ0y4ZNvfny/GlYaex5i2j55h1VUO4lom7ojcrwHo2kobk3qWi2RYM2d+RRaZjfE8zJKqzQlC/+k2UVonN01UomTjl6OItOtXrTWax686UzWel3V1w59Y4p1z5da33dnj8+I9ZeTJxF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"/> <p>If you’ve never used this module before or just aren’t sure which class is right for your task, <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> is most likely what you need. It instantiates a <a class="reference internal" href="#concrete-paths"><span class="std std-ref">concrete path</span></a> for the platform the code is running on.</p> <p>Pure paths are useful in some special cases; for example:</p> <ol class="arabic simple"> <li>If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a <a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code>WindowsPath</code></a> when running on Unix, but you can instantiate <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>.</li> <li>You want to make sure that your code only manipulates paths without actually accessing the OS. In this case, instantiating one of the pure classes may be useful since those simply don’t have any OS-accessing operations.</li> </ol> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><strong>PEP 428</strong>: The pathlib module – object-oriented filesystem paths.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>For low-level path manipulation on strings, you can also use the <a class="reference internal" href="os.path#module-os.path" title="os.path: Operations on pathnames."><code>os.path</code></a> module.</p> </div> <h2 id="basic-use">
<span class="section-number">11.1.1. </span>Basic use</h2> <p>Importing the main class:</p> <pre data-language="python">&gt;&gt;&gt; from pathlib import Path
</pre> <p>Listing subdirectories:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('.')
&gt;&gt;&gt; [x for x in p.iterdir() if x.is_dir()]
[PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),
 PosixPath('__pycache__'), PosixPath('build')]
</pre> <p>Listing Python source files in this directory tree:</p> <pre data-language="python">&gt;&gt;&gt; list(p.glob('**/*.py'))
[PosixPath('test_pathlib.py'), PosixPath('setup.py'),
 PosixPath('pathlib.py'), PosixPath('docs/conf.py'),
 PosixPath('build/lib/pathlib.py')]
</pre> <p>Navigating inside a directory tree:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('/etc')
&gt;&gt;&gt; q = p / 'init.d' / 'reboot'
&gt;&gt;&gt; q
PosixPath('/etc/init.d/reboot')
&gt;&gt;&gt; q.resolve()
PosixPath('/etc/rc.d/init.d/halt')
</pre> <p>Querying path properties:</p> <pre data-language="python">&gt;&gt;&gt; q.exists()
True
&gt;&gt;&gt; q.is_dir()
False
</pre> <p>Opening a file:</p> <pre data-language="python">&gt;&gt;&gt; with q.open() as f: f.readline()
...
'#!/bin/bash\n'
</pre> <h2 id="id1">
<span class="section-number">11.1.2. </span>Pure paths</h2> <p id="pure-paths">Pure path objects provide path-handling operations which don’t actually access a filesystem. There are three ways to access these classes, which we also call <em>flavours</em>:</p> <dl class="class"> <dt id="pathlib.PurePath">
<code>class pathlib.PurePath(*pathsegments)</code> </dt> <dd>
<p>A generic class that represents the system’s path flavour (instantiating it creates either a <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a> or a <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; PurePath('setup.py')      # Running on a Unix machine
PurePosixPath('setup.py')
</pre> <p>Each element of <em>pathsegments</em> can be either a string representing a path segment, an object implementing the <a class="reference internal" href="os#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface which returns a string, or another path object:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('foo', 'some/path', 'bar')
PurePosixPath('foo/some/path/bar')
&gt;&gt;&gt; PurePath(Path('foo'), Path('bar'))
PurePosixPath('foo/bar')
</pre> <p>When <em>pathsegments</em> is empty, the current directory is assumed:</p> <pre data-language="python">&gt;&gt;&gt; PurePath()
PurePosixPath('.')
</pre> <p>When several absolute paths are given, the last is taken as an anchor (mimicking <a class="reference internal" href="os.path#os.path.join" title="os.path.join"><code>os.path.join()</code></a>’s behaviour):</p> <pre data-language="python">&gt;&gt;&gt; PurePath('/etc', '/usr', 'lib64')
PurePosixPath('/usr/lib64')
&gt;&gt;&gt; PureWindowsPath('c:/Windows', 'd:bar')
PureWindowsPath('d:bar')
</pre> <p>However, in a Windows path, changing the local root doesn’t discard the previous drive setting:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Windows', '/Program Files')
PureWindowsPath('c:/Program Files')
</pre> <p>Spurious slashes and single dots are collapsed, but double dots (<code>'..'</code>) are not, since this would change the meaning of a path in the face of symbolic links:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('foo//bar')
PurePosixPath('foo/bar')
&gt;&gt;&gt; PurePath('foo/./bar')
PurePosixPath('foo/bar')
&gt;&gt;&gt; PurePath('foo/../bar')
PurePosixPath('foo/../bar')
</pre> <p>(a naïve approach would make <code>PurePosixPath('foo/../bar')</code> equivalent to <code>PurePosixPath('bar')</code>, which is wrong if <code>foo</code> is a symbolic link to another directory)</p> <p>Pure path objects implement the <a class="reference internal" href="os#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface, allowing them to be used anywhere the interface is accepted.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6: </span>Added support for the <a class="reference internal" href="os#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> interface.</p> </div> </dd>
</dl> <dl class="class"> <dt id="pathlib.PurePosixPath">
<code>class pathlib.PurePosixPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this path flavour represents non-Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/etc')
PurePosixPath('/etc')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="pathlib.PureWindowsPath">
<code>class pathlib.PureWindowsPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this path flavour represents Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/')
PureWindowsPath('c:/Program Files')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <p>Regardless of the system you’re running on, you can instantiate all of these classes, since they don’t provide any operation that does system calls.</p> <h3 id="general-properties">
<span class="section-number">11.1.2.1. </span>General properties</h3> <p>Paths are immutable and hashable. Paths of a same flavour are comparable and orderable. These properties respect the flavour’s case-folding semantics:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('foo') == PurePosixPath('FOO')
False
&gt;&gt;&gt; PureWindowsPath('foo') == PureWindowsPath('FOO')
True
&gt;&gt;&gt; PureWindowsPath('FOO') in { PureWindowsPath('foo') }
True
&gt;&gt;&gt; PureWindowsPath('C:') &lt; PureWindowsPath('d:')
True
</pre> <p>Paths of a different flavour compare unequal and cannot be ordered:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('foo') == PurePosixPath('foo')
False
&gt;&gt;&gt; PureWindowsPath('foo') &lt; PurePosixPath('foo')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'PureWindowsPath' and 'PurePosixPath'
</pre> <h3 id="operators">
<span class="section-number">11.1.2.2. </span>Operators</h3> <p>The slash operator helps create child paths, similarly to <a class="reference internal" href="os.path#os.path.join" title="os.path.join"><code>os.path.join()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; p
PurePosixPath('/etc')
&gt;&gt;&gt; p / 'init.d' / 'apache2'
PurePosixPath('/etc/init.d/apache2')
&gt;&gt;&gt; q = PurePath('bin')
&gt;&gt;&gt; '/usr' / q
PurePosixPath('/usr/bin')
</pre> <p>A path object can be used anywhere an object implementing <a class="reference internal" href="os#os.PathLike" title="os.PathLike"><code>os.PathLike</code></a> is accepted:</p> <pre data-language="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; os.fspath(p)
'/etc'
</pre> <p>The string representation of a path is the raw filesystem path itself (in native form, e.g. with backslashes under Windows), which you can pass to any function taking a file path as a string:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/etc')
&gt;&gt;&gt; str(p)
'/etc'
&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files')
&gt;&gt;&gt; str(p)
'c:\\Program Files'
</pre> <p>Similarly, calling <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> on a path gives the raw filesystem path as a bytes object, as encoded by <a class="reference internal" href="os#os.fsencode" title="os.fsencode"><code>os.fsencode()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; bytes(p)
b'/etc'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Calling <a class="reference internal" href="stdtypes#bytes" title="bytes"><code>bytes</code></a> is only recommended under Unix. Under Windows, the unicode form is the canonical representation of filesystem paths.</p> </div> <h3 id="accessing-individual-parts">
<span class="section-number">11.1.2.3. </span>Accessing individual parts</h3> <p>To access the individual “parts” (components) of a path, use the following property:</p> <dl class="data"> <dt id="pathlib.PurePath.parts">
<code>PurePath.parts</code> </dt> <dd>
<p>A tuple giving access to the path’s various components:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePath('/usr/bin/python3')
&gt;&gt;&gt; p.parts
('/', 'usr', 'bin', 'python3')

&gt;&gt;&gt; p = PureWindowsPath('c:/Program Files/PSF')
&gt;&gt;&gt; p.parts
('c:\\', 'Program Files', 'PSF')
</pre> <p>(note how the drive and local root are regrouped in a single part)</p> </dd>
</dl> <h3 id="methods-and-properties">
<span class="section-number">11.1.2.4. </span>Methods and properties</h3> <p>Pure paths provide the following methods and properties:</p> <dl class="data"> <dt id="pathlib.PurePath.drive">
<code>PurePath.drive</code> </dt> <dd>
<p>A string representing the drive letter or name, if any:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').drive
'c:'
&gt;&gt;&gt; PureWindowsPath('/Program Files/').drive
''
&gt;&gt;&gt; PurePosixPath('/etc').drive
''
</pre> <p>UNC shares are also considered drives:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//host/share/foo.txt').drive
'\\\\host\\share'
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.root">
<code>PurePath.root</code> </dt> <dd>
<p>A string representing the (local or global) root, if any:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').root
'\\'
&gt;&gt;&gt; PureWindowsPath('c:Program Files/').root
''
&gt;&gt;&gt; PurePosixPath('/etc').root
'/'
</pre> <p>UNC shares always have a root:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//host/share').root
'\\'
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.anchor">
<code>PurePath.anchor</code> </dt> <dd>
<p>The concatenation of the drive and root:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('c:/Program Files/').anchor
'c:\\'
&gt;&gt;&gt; PureWindowsPath('c:Program Files/').anchor
'c:'
&gt;&gt;&gt; PurePosixPath('/etc').anchor
'/'
&gt;&gt;&gt; PureWindowsPath('//host/share').anchor
'\\\\host\\share\\'
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.parents">
<code>PurePath.parents</code> </dt> <dd>
<p>An immutable sequence providing access to the logical ancestors of the path:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/foo/bar/setup.py')
&gt;&gt;&gt; p.parents[0]
PureWindowsPath('c:/foo/bar')
&gt;&gt;&gt; p.parents[1]
PureWindowsPath('c:/foo')
&gt;&gt;&gt; p.parents[2]
PureWindowsPath('c:/')
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.parent">
<code>PurePath.parent</code> </dt> <dd>
<p>The logical parent of the path:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/a/b/c/d')
&gt;&gt;&gt; p.parent
PurePosixPath('/a/b/c')
</pre> <p>You cannot go past an anchor, or empty path:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/')
&gt;&gt;&gt; p.parent
PurePosixPath('/')
&gt;&gt;&gt; p = PurePosixPath('.')
&gt;&gt;&gt; p.parent
PurePosixPath('.')
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a purely lexical operation, hence the following behaviour:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('foo/..')
&gt;&gt;&gt; p.parent
PurePosixPath('foo')
</pre> <p>If you want to walk an arbitrary filesystem path upwards, it is recommended to first call <a class="reference internal" href="#pathlib.Path.resolve" title="pathlib.Path.resolve"><code>Path.resolve()</code></a> so as to resolve symlinks and eliminate <code>“..”</code> components.</p> </div> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.name">
<code>PurePath.name</code> </dt> <dd>
<p>A string representing the final path component, excluding the drive and root, if any:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library/setup.py').name
'setup.py'
</pre> <p>UNC drive names are not considered:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('//some/share/setup.py').name
'setup.py'
&gt;&gt;&gt; PureWindowsPath('//some/share').name
''
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.suffix">
<code>PurePath.suffix</code> </dt> <dd>
<p>The file extension of the final component, if any:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library/setup.py').suffix
'.py'
&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffix
'.gz'
&gt;&gt;&gt; PurePosixPath('my/library').suffix
''
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.suffixes">
<code>PurePath.suffixes</code> </dt> <dd>
<p>A list of the path’s file extensions:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library.tar.gar').suffixes
['.tar', '.gar']
&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').suffixes
['.tar', '.gz']
&gt;&gt;&gt; PurePosixPath('my/library').suffixes
[]
</pre> </dd>
</dl> <dl class="data"> <dt id="pathlib.PurePath.stem">
<code>PurePath.stem</code> </dt> <dd>
<p>The final path component, without its suffix:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('my/library.tar.gz').stem
'library.tar'
&gt;&gt;&gt; PurePosixPath('my/library.tar').stem
'library'
&gt;&gt;&gt; PurePosixPath('my/library').stem
'library'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.as_posix">
<code>PurePath.as_posix()</code> </dt> <dd>
<p>Return a string representation of the path with forward slashes (<code>/</code>):</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:\\windows')
&gt;&gt;&gt; str(p)
'c:\\windows'
&gt;&gt;&gt; p.as_posix()
'c:/windows'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.as_uri">
<code>PurePath.as_uri()</code> </dt> <dd>
<p>Represent the path as a <code>file</code> URI. <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> is raised if the path isn’t absolute.</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')
&gt;&gt;&gt; p.as_uri()
'file:///etc/passwd'
&gt;&gt;&gt; p = PureWindowsPath('c:/Windows')
&gt;&gt;&gt; p.as_uri()
'file:///c:/Windows'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.is_absolute">
<code>PurePath.is_absolute()</code> </dt> <dd>
<p>Return whether the path is absolute or not. A path is considered absolute if it has both a root and (if the flavour allows) a drive:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/a/b').is_absolute()
True
&gt;&gt;&gt; PurePosixPath('a/b').is_absolute()
False

&gt;&gt;&gt; PureWindowsPath('c:/a/b').is_absolute()
True
&gt;&gt;&gt; PureWindowsPath('/a/b').is_absolute()
False
&gt;&gt;&gt; PureWindowsPath('c:').is_absolute()
False
&gt;&gt;&gt; PureWindowsPath('//some/share').is_absolute()
True
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.is_reserved">
<code>PurePath.is_reserved()</code> </dt> <dd>
<p>With <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>, return <code>True</code> if the path is considered reserved under Windows, <code>False</code> otherwise. With <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a>, <code>False</code> is always returned.</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('nul').is_reserved()
True
&gt;&gt;&gt; PurePosixPath('nul').is_reserved()
False
</pre> <p>File system calls on reserved paths can fail mysteriously or have unintended effects.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.joinpath">
<code>PurePath.joinpath(*other)</code> </dt> <dd>
<p>Calling this method is equivalent to combining the path with each of the <em>other</em> arguments in turn:</p> <pre data-language="python">&gt;&gt;&gt; PurePosixPath('/etc').joinpath('passwd')
PurePosixPath('/etc/passwd')
&gt;&gt;&gt; PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
PurePosixPath('/etc/passwd')
&gt;&gt;&gt; PurePosixPath('/etc').joinpath('init.d', 'apache2')
PurePosixPath('/etc/init.d/apache2')
&gt;&gt;&gt; PureWindowsPath('c:').joinpath('/Program Files')
PureWindowsPath('c:/Program Files')
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.match">
<code>PurePath.match(pattern)</code> </dt> <dd>
<p>Match this path against the provided glob-style pattern. Return <code>True</code> if matching is successful, <code>False</code> otherwise.</p> <p>If <em>pattern</em> is relative, the path can be either relative or absolute, and matching is done from the right:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('a/b.py').match('*.py')
True
&gt;&gt;&gt; PurePath('/a/b/c.py').match('b/*.py')
True
&gt;&gt;&gt; PurePath('/a/b/c.py').match('a/*.py')
False
</pre> <p>If <em>pattern</em> is absolute, the path must be absolute, and the whole path must match:</p> <pre data-language="python">&gt;&gt;&gt; PurePath('/a.py').match('/*.py')
True
&gt;&gt;&gt; PurePath('a/b.py').match('/*.py')
False
</pre> <p>As with other methods, case-sensitivity is observed:</p> <pre data-language="python">&gt;&gt;&gt; PureWindowsPath('b.py').match('*.PY')
True
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.relative_to">
<code>PurePath.relative_to(*other)</code> </dt> <dd>
<p>Compute a version of this path relative to the path represented by <em>other</em>. If it’s impossible, ValueError is raised:</p> <pre data-language="python">&gt;&gt;&gt; p = PurePosixPath('/etc/passwd')
&gt;&gt;&gt; p.relative_to('/')
PurePosixPath('etc/passwd')
&gt;&gt;&gt; p.relative_to('/etc')
PurePosixPath('passwd')
&gt;&gt;&gt; p.relative_to('/usr')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "pathlib.py", line 694, in relative_to
    .format(str(self), str(formatted)))
ValueError: '/etc/passwd' does not start with '/usr'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.with_name">
<code>PurePath.with_name(name)</code> </dt> <dd>
<p>Return a new path with the <a class="reference internal" href="#pathlib.PurePath.name" title="pathlib.PurePath.name"><code>name</code></a> changed. If the original path doesn’t have a name, ValueError is raised:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_name('setup.py')
PureWindowsPath('c:/Downloads/setup.py')
&gt;&gt;&gt; p = PureWindowsPath('c:/')
&gt;&gt;&gt; p.with_name('setup.py')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/antoine/cpython/default/Lib/pathlib.py", line 751, in with_name
    raise ValueError("%r has an empty name" % (self,))
ValueError: PureWindowsPath('c:/') has an empty name
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.PurePath.with_suffix">
<code>PurePath.with_suffix(suffix)</code> </dt> <dd>
<p>Return a new path with the <a class="reference internal" href="#pathlib.PurePath.suffix" title="pathlib.PurePath.suffix"><code>suffix</code></a> changed. If the original path doesn’t have a suffix, the new <em>suffix</em> is appended instead. If the <em>suffix</em> is an empty string, the original suffix is removed:</p> <pre data-language="python">&gt;&gt;&gt; p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
&gt;&gt;&gt; p.with_suffix('.bz2')
PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
&gt;&gt;&gt; p = PureWindowsPath('README')
&gt;&gt;&gt; p.with_suffix('.txt')
PureWindowsPath('README.txt')
&gt;&gt;&gt; p = PureWindowsPath('README.txt')
&gt;&gt;&gt; p.with_suffix('')
PureWindowsPath('README')
</pre> </dd>
</dl> <h2 id="id2">
<span class="section-number">11.1.3. </span>Concrete paths</h2> <p id="concrete-paths">Concrete paths are subclasses of the pure path classes. In addition to operations provided by the latter, they also provide methods to do system calls on path objects. There are three ways to instantiate concrete paths:</p> <dl class="class"> <dt id="pathlib.Path">
<code>class pathlib.Path(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>, this class represents concrete paths of the system’s path flavour (instantiating it creates either a <a class="reference internal" href="#pathlib.PosixPath" title="pathlib.PosixPath"><code>PosixPath</code></a> or a <a class="reference internal" href="#pathlib.WindowsPath" title="pathlib.WindowsPath"><code>WindowsPath</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; Path('setup.py')
PosixPath('setup.py')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="pathlib.PosixPath">
<code>class pathlib.PosixPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> and <a class="reference internal" href="#pathlib.PurePosixPath" title="pathlib.PurePosixPath"><code>PurePosixPath</code></a>, this class represents concrete non-Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; PosixPath('/etc')
PosixPath('/etc')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <dl class="class"> <dt id="pathlib.WindowsPath">
<code>class pathlib.WindowsPath(*pathsegments)</code> </dt> <dd>
<p>A subclass of <a class="reference internal" href="#pathlib.Path" title="pathlib.Path"><code>Path</code></a> and <a class="reference internal" href="#pathlib.PureWindowsPath" title="pathlib.PureWindowsPath"><code>PureWindowsPath</code></a>, this class represents concrete Windows filesystem paths:</p> <pre data-language="python">&gt;&gt;&gt; WindowsPath('c:/Program Files/')
WindowsPath('c:/Program Files')
</pre> <p><em>pathsegments</em> is specified similarly to <a class="reference internal" href="#pathlib.PurePath" title="pathlib.PurePath"><code>PurePath</code></a>.</p> </dd>
</dl> <p>You can only instantiate the class flavour that corresponds to your system (allowing system calls on non-compatible path flavours could lead to bugs or failures in your application):</p> <pre data-language="python">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.name
'posix'
&gt;&gt;&gt; Path('setup.py')
PosixPath('setup.py')
&gt;&gt;&gt; PosixPath('setup.py')
PosixPath('setup.py')
&gt;&gt;&gt; WindowsPath('setup.py')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "pathlib.py", line 798, in __new__
    % (cls.__name__,))
NotImplementedError: cannot instantiate 'WindowsPath' on your system
</pre> <h3 id="methods">
<span class="section-number">11.1.3.1. </span>Methods</h3> <p>Concrete paths provide the following methods in addition to pure paths methods. Many of these methods can raise an <a class="reference internal" href="exceptions#OSError" title="OSError"><code>OSError</code></a> if a system call fails (for example because the path doesn’t exist):</p> <dl class="method"> <dt id="pathlib.Path.cwd">
<code>classmethod Path.cwd()</code> </dt> <dd>
<p>Return a new path object representing the current directory (as returned by <a class="reference internal" href="os#os.getcwd" title="os.getcwd"><code>os.getcwd()</code></a>):</p> <pre data-language="python">&gt;&gt;&gt; Path.cwd()
PosixPath('/home/antoine/pathlib')
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.home">
<code>classmethod Path.home()</code> </dt> <dd>
<p>Return a new path object representing the user’s home directory (as returned by <a class="reference internal" href="os.path#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a> with <code>~</code> construct):</p> <pre data-language="python">&gt;&gt;&gt; Path.home()
PosixPath('/home/antoine')
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.stat">
<code>Path.stat()</code> </dt> <dd>
<p>Return information about this path (similarly to <a class="reference internal" href="os#os.stat" title="os.stat"><code>os.stat()</code></a>). The result is looked up at each call to this method.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; p.stat().st_size
956
&gt;&gt;&gt; p.stat().st_mtime
1327883547.852554
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.chmod">
<code>Path.chmod(mode)</code> </dt> <dd>
<p>Change the file mode and permissions, like <a class="reference internal" href="os#os.chmod" title="os.chmod"><code>os.chmod()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; p.stat().st_mode
33277
&gt;&gt;&gt; p.chmod(0o444)
&gt;&gt;&gt; p.stat().st_mode
33060
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.exists">
<code>Path.exists()</code> </dt> <dd>
<p>Whether the path points to an existing file or directory:</p> <pre data-language="python">&gt;&gt;&gt; Path('.').exists()
True
&gt;&gt;&gt; Path('setup.py').exists()
True
&gt;&gt;&gt; Path('/etc').exists()
True
&gt;&gt;&gt; Path('nonexistentfile').exists()
False
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the path points to a symlink, <a class="reference internal" href="#pathlib.Path.exists" title="pathlib.Path.exists"><code>exists()</code></a> returns whether the symlink <em>points to</em> an existing file or directory.</p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.expanduser">
<code>Path.expanduser()</code> </dt> <dd>
<p>Return a new path with expanded <code>~</code> and <code>~user</code> constructs, as returned by <a class="reference internal" href="os.path#os.path.expanduser" title="os.path.expanduser"><code>os.path.expanduser()</code></a>:</p> <pre data-language="python">&gt;&gt;&gt; p = PosixPath('~/films/Monty Python')
&gt;&gt;&gt; p.expanduser()
PosixPath('/home/eric/films/Monty Python')
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.glob">
<code>Path.glob(pattern)</code> </dt> <dd>
<p>Glob the given <em>pattern</em> in the directory represented by this path, yielding all matching files (of any kind):</p> <pre data-language="python">&gt;&gt;&gt; sorted(Path('.').glob('*.py'))
[PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
&gt;&gt;&gt; sorted(Path('.').glob('*/*.py'))
[PosixPath('docs/conf.py')]
</pre> <p>The “<code>**</code>” pattern means “this directory and all subdirectories, recursively”. In other words, it enables recursive globbing:</p> <pre data-language="python">&gt;&gt;&gt; sorted(Path('.').glob('**/*.py'))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Using the “<code>**</code>” pattern in large directory trees may consume an inordinate amount of time.</p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.group">
<code>Path.group()</code> </dt> <dd>
<p>Return the name of the group owning the file. <a class="reference internal" href="exceptions#KeyError" title="KeyError"><code>KeyError</code></a> is raised if the file’s gid isn’t found in the system database.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_dir">
<code>Path.is_dir()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a directory (or a symbolic link pointing to a directory), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_file">
<code>Path.is_file()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a regular file (or a symbolic link pointing to a regular file), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_symlink">
<code>Path.is_symlink()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a symbolic link, <code>False</code> otherwise.</p> <p><code>False</code> is also returned if the path doesn’t exist; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_socket">
<code>Path.is_socket()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a Unix socket (or a symbolic link pointing to a Unix socket), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_fifo">
<code>Path.is_fifo()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a FIFO (or a symbolic link pointing to a FIFO), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_block_device">
<code>Path.is_block_device()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a block device (or a symbolic link pointing to a block device), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.is_char_device">
<code>Path.is_char_device()</code> </dt> <dd>
<p>Return <code>True</code> if the path points to a character device (or a symbolic link pointing to a character device), <code>False</code> if it points to another kind of file.</p> <p><code>False</code> is also returned if the path doesn’t exist or is a broken symlink; other errors (such as permission errors) are propagated.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.iterdir">
<code>Path.iterdir()</code> </dt> <dd>
<p>When the path points to a directory, yield path objects of the directory contents:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('docs')
&gt;&gt;&gt; for child in p.iterdir(): child
...
PosixPath('docs/conf.py')
PosixPath('docs/_templates')
PosixPath('docs/make.bat')
PosixPath('docs/index.rst')
PosixPath('docs/_build')
PosixPath('docs/_static')
PosixPath('docs/Makefile')
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.lchmod">
<code>Path.lchmod(mode)</code> </dt> <dd>
<p>Like <a class="reference internal" href="#pathlib.Path.chmod" title="pathlib.Path.chmod"><code>Path.chmod()</code></a> but, if the path points to a symbolic link, the symbolic link’s mode is changed rather than its target’s.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.lstat">
<code>Path.lstat()</code> </dt> <dd>
<p>Like <a class="reference internal" href="#pathlib.Path.stat" title="pathlib.Path.stat"><code>Path.stat()</code></a> but, if the path points to a symbolic link, return the symbolic link’s information rather than its target’s.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.mkdir">
<code>Path.mkdir(mode=0o777, parents=False, exist_ok=False)</code> </dt> <dd>
<p>Create a new directory at this given path. If <em>mode</em> is given, it is combined with the process’ <code>umask</code> value to determine the file mode and access flags. If the path already exists, <a class="reference internal" href="exceptions#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised.</p> <p>If <em>parents</em> is true, any missing parents of this path are created as needed; they are created with the default permissions without taking <em>mode</em> into account (mimicking the POSIX <code>mkdir -p</code> command).</p> <p>If <em>parents</em> is false (the default), a missing parent raises <a class="reference internal" href="exceptions#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a>.</p> <p>If <em>exist_ok</em> is false (the default), <a class="reference internal" href="exceptions#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised if the target directory already exists.</p> <p>If <em>exist_ok</em> is true, <a class="reference internal" href="exceptions#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> exceptions will be ignored (same behavior as the POSIX <code>mkdir -p</code> command), but only if the last path component is not an existing non-directory file.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.5: </span>The <em>exist_ok</em> parameter was added.</p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.open">
<code>Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</code> </dt> <dd>
<p>Open the file pointed to by the path, like the built-in <a class="reference internal" href="functions#open" title="open"><code>open()</code></a> function does:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('setup.py')
&gt;&gt;&gt; with p.open() as f:
...     f.readline()
...
'#!/usr/bin/env python3\n'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.owner">
<code>Path.owner()</code> </dt> <dd>
<p>Return the name of the user owning the file. <a class="reference internal" href="exceptions#KeyError" title="KeyError"><code>KeyError</code></a> is raised if the file’s uid isn’t found in the system database.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.read_bytes">
<code>Path.read_bytes()</code> </dt> <dd>
<p>Return the binary contents of the pointed-to file as a bytes object:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_binary_file')
&gt;&gt;&gt; p.write_bytes(b'Binary file contents')
20
&gt;&gt;&gt; p.read_bytes()
b'Binary file contents'
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.read_text">
<code>Path.read_text(encoding=None, errors=None)</code> </dt> <dd>
<p>Return the decoded contents of the pointed-to file as a string:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_text_file')
&gt;&gt;&gt; p.write_text('Text file contents')
18
&gt;&gt;&gt; p.read_text()
'Text file contents'
</pre> <p>The file is opened and then closed. The optional parameters have the same meaning as in <a class="reference internal" href="functions#open" title="open"><code>open()</code></a>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.rename">
<code>Path.rename(target)</code> </dt> <dd>
<p>Rename this file or directory to the given <em>target</em>. On Unix, if <em>target</em> exists and is a file, it will be replaced silently if the user has permission. <em>target</em> can be either a string or another path object:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('foo')
&gt;&gt;&gt; p.open('w').write('some text')
9
&gt;&gt;&gt; target = Path('bar')
&gt;&gt;&gt; p.rename(target)
&gt;&gt;&gt; target.open().read()
'some text'
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.replace">
<code>Path.replace(target)</code> </dt> <dd>
<p>Rename this file or directory to the given <em>target</em>. If <em>target</em> points to an existing file or directory, it will be unconditionally replaced.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.resolve">
<code>Path.resolve(strict=False)</code> </dt> <dd>
<p>Make the path absolute, resolving any symlinks. A new path object is returned:</p> <pre data-language="python">&gt;&gt;&gt; p = Path()
&gt;&gt;&gt; p
PosixPath('.')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib')
</pre> <p>“<code>..</code>” components are also eliminated (this is the only method to do so):</p> <pre data-language="python">&gt;&gt;&gt; p = Path('docs/../setup.py')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')
</pre> <p>If the path doesn’t exist and <em>strict</em> is <code>True</code>, <a class="reference internal" href="exceptions#FileNotFoundError" title="FileNotFoundError"><code>FileNotFoundError</code></a> is raised. If <em>strict</em> is <code>False</code>, the path is resolved as far as possible and any remainder is appended without checking whether it exists. If an infinite loop is encountered along the resolution path, <a class="reference internal" href="exceptions#RuntimeError" title="RuntimeError"><code>RuntimeError</code></a> is raised.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6: </span>The <em>strict</em> argument.</p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.rglob">
<code>Path.rglob(pattern)</code> </dt> <dd>
<p>This is like calling <a class="reference internal" href="#pathlib.Path.glob" title="pathlib.Path.glob"><code>Path.glob()</code></a> with “<code>**</code>” added in front of the given <em>pattern</em>:</p> <pre data-language="python">&gt;&gt;&gt; sorted(Path().rglob("*.py"))
[PosixPath('build/lib/pathlib.py'),
 PosixPath('docs/conf.py'),
 PosixPath('pathlib.py'),
 PosixPath('setup.py'),
 PosixPath('test_pathlib.py')]
</pre> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.rmdir">
<code>Path.rmdir()</code> </dt> <dd>
<p>Remove this directory. The directory must be empty.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.samefile">
<code>Path.samefile(other_path)</code> </dt> <dd>
<p>Return whether this path points to the same file as <em>other_path</em>, which can be either a Path object, or a string. The semantics are similar to <a class="reference internal" href="os.path#os.path.samefile" title="os.path.samefile"><code>os.path.samefile()</code></a> and <a class="reference internal" href="os.path#os.path.samestat" title="os.path.samestat"><code>os.path.samestat()</code></a>.</p> <p>An <a class="reference internal" href="exceptions#OSError" title="OSError"><code>OSError</code></a> can be raised if either file cannot be accessed for some reason.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('spam')
&gt;&gt;&gt; q = Path('eggs')
&gt;&gt;&gt; p.samefile(q)
False
&gt;&gt;&gt; p.samefile('spam')
True
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.symlink_to">
<code>Path.symlink_to(target, target_is_directory=False)</code> </dt> <dd>
<p>Make this path a symbolic link to <em>target</em>. Under Windows, <em>target_is_directory</em> must be true (default <code>False</code>) if the link’s target is a directory. Under POSIX, <em>target_is_directory</em>’s value is ignored.</p> <pre data-language="python">&gt;&gt;&gt; p = Path('mylink')
&gt;&gt;&gt; p.symlink_to('setup.py')
&gt;&gt;&gt; p.resolve()
PosixPath('/home/antoine/pathlib/setup.py')
&gt;&gt;&gt; p.stat().st_size
956
&gt;&gt;&gt; p.lstat().st_size
8
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The order of arguments (link, target) is the reverse of <a class="reference internal" href="os#os.symlink" title="os.symlink"><code>os.symlink()</code></a>’s.</p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.touch">
<code>Path.touch(mode=0o666, exist_ok=True)</code> </dt> <dd>
<p>Create a file at this given path. If <em>mode</em> is given, it is combined with the process’ <code>umask</code> value to determine the file mode and access flags. If the file already exists, the function succeeds if <em>exist_ok</em> is true (and its modification time is updated to the current time), otherwise <a class="reference internal" href="exceptions#FileExistsError" title="FileExistsError"><code>FileExistsError</code></a> is raised.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.unlink">
<code>Path.unlink()</code> </dt> <dd>
<p>Remove this file or symbolic link. If the path points to a directory, use <a class="reference internal" href="#pathlib.Path.rmdir" title="pathlib.Path.rmdir"><code>Path.rmdir()</code></a> instead.</p> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.write_bytes">
<code>Path.write_bytes(data)</code> </dt> <dd>
<p>Open the file pointed to in bytes mode, write <em>data</em> to it, and close the file:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_binary_file')
&gt;&gt;&gt; p.write_bytes(b'Binary file contents')
20
&gt;&gt;&gt; p.read_bytes()
b'Binary file contents'
</pre> <p>An existing file of the same name is overwritten.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="pathlib.Path.write_text">
<code>Path.write_text(data, encoding=None, errors=None)</code> </dt> <dd>
<p>Open the file pointed to in text mode, write <em>data</em> to it, and close the file:</p> <pre data-language="python">&gt;&gt;&gt; p = Path('my_text_file')
&gt;&gt;&gt; p.write_text('Text file contents')
18
&gt;&gt;&gt; p.read_text()
'Text file contents'
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.5.</span></p> </div> </dd>
</dl><div class="_attribution">
<p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br/>Licensed under the PSF License.<br/>
https://docs.python.org/3.6/library/pathlib.html
</p>
</div>
