<h1 id="statistics-mathematical-statistics-functions"> statistics — Mathematical statistics functions</h1> <div class="versionadded" id="module-statistics"> <p><span class="versionmodified added">New in version 3.4.</span></p> </div> <p><strong>Source code:</strong> Lib/statistics.py</p> <p>This module provides functions for calculating mathematical statistics of numeric (<code>Real</code>-valued) data.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Unless explicitly noted otherwise, these functions support <a class="reference internal" href="functions#int" title="int"><code>int</code></a>, <a class="reference internal" href="functions#float" title="float"><code>float</code></a>, <a class="reference internal" href="decimal#decimal.Decimal" title="decimal.Decimal"><code>decimal.Decimal</code></a> and <a class="reference internal" href="fractions#fractions.Fraction" title="fractions.Fraction"><code>fractions.Fraction</code></a>. Behaviour with other types (whether in the numeric tower or not) is currently unsupported. Mixed types are also undefined and implementation-dependent. If your input data consists of mixed types, you may be able to use <a class="reference internal" href="functions#map" title="map"><code>map()</code></a> to ensure a consistent result, e.g. <code>map(float, input_data)</code>.</p> </div> <h2 id="averages-and-measures-of-central-location">
<span class="section-number">9.7.1. </span>Averages and measures of central location</h2> <p>These functions calculate an average or typical value from a population or sample.</p> <table class="docutils align-default"> <tr>
<td><p><a class="reference internal" href="#statistics.mean" title="statistics.mean"><code>mean()</code></a></p></td> <td><p>Arithmetic mean (“average”) of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.harmonic_mean" title="statistics.harmonic_mean"><code>harmonic_mean()</code></a></p></td> <td><p>Harmonic mean of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.median" title="statistics.median"><code>median()</code></a></p></td> <td><p>Median (middle value) of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.median_low" title="statistics.median_low"><code>median_low()</code></a></p></td> <td><p>Low median of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.median_high" title="statistics.median_high"><code>median_high()</code></a></p></td> <td><p>High median of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.median_grouped" title="statistics.median_grouped"><code>median_grouped()</code></a></p></td> <td><p>Median, or 50th percentile, of grouped data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.mode" title="statistics.mode"><code>mode()</code></a></p></td> <td><p>Mode (most common value) of discrete data.</p></td> </tr> </table> <h2 id="measures-of-spread">
<span class="section-number">9.7.2. </span>Measures of spread</h2> <p>These functions calculate a measure of how much the population or sample tends to deviate from the typical or average values.</p> <table class="docutils align-default"> <tr>
<td><p><a class="reference internal" href="#statistics.pstdev" title="statistics.pstdev"><code>pstdev()</code></a></p></td> <td><p>Population standard deviation of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.pvariance" title="statistics.pvariance"><code>pvariance()</code></a></p></td> <td><p>Population variance of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.stdev" title="statistics.stdev"><code>stdev()</code></a></p></td> <td><p>Sample standard deviation of data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#statistics.variance" title="statistics.variance"><code>variance()</code></a></p></td> <td><p>Sample variance of data.</p></td> </tr> </table> <h2 id="function-details">
<span class="section-number">9.7.3. </span>Function details</h2> <p>Note: The functions do not require the data given to them to be sorted. However, for reading convenience, most of the examples show sorted sequences.</p> <dl class="function"> <dt id="statistics.mean">
<code>statistics.mean(data)</code> </dt> <dd>
<p>Return the sample arithmetic mean of <em>data</em> which can be a sequence or iterator.</p> <p>The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called “the average”, although it is only one of many different mathematical averages. It is a measure of the central location of the data.</p> <p>If <em>data</em> is empty, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> will be raised.</p> <p>Some examples of use:</p> <pre data-language="pycon3">&gt;&gt;&gt; mean([1, 2, 3, 4, 4])
2.8
&gt;&gt;&gt; mean([-1.0, 2.5, 3.25, 5.75])
2.625

&gt;&gt;&gt; from fractions import Fraction as F
&gt;&gt;&gt; mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])
Fraction(13, 21)

&gt;&gt;&gt; from decimal import Decimal as D
&gt;&gt;&gt; mean([D("0.5"), D("0.75"), D("0.625"), D("0.375")])
Decimal('0.5625')
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The mean is strongly affected by outliers and is not a robust estimator for central location: the mean is not necessarily a typical example of the data points. For more robust, although less efficient, measures of central location, see <a class="reference internal" href="#statistics.median" title="statistics.median"><code>median()</code></a> and <a class="reference internal" href="#statistics.mode" title="statistics.mode"><code>mode()</code></a>. (In this case, “efficient” refers to statistical efficiency rather than computational efficiency.)</p> <p>The sample mean gives an unbiased estimate of the true population mean, which means that, taken on average over all the possible samples, <code>mean(sample)</code> converges on the true mean of the entire population. If <em>data</em> represents the entire population rather than a sample, then <code>mean(data)</code> is equivalent to calculating the true population mean μ.</p> </div> </dd>
</dl> <dl class="function"> <dt id="statistics.harmonic_mean">
<code>statistics.harmonic_mean(data)</code> </dt> <dd>
<p>Return the harmonic mean of <em>data</em>, a sequence or iterator of real-valued numbers.</p> <p>The harmonic mean, sometimes called the subcontrary mean, is the reciprocal of the arithmetic <a class="reference internal" href="#statistics.mean" title="statistics.mean"><code>mean()</code></a> of the reciprocals of the data. For example, the harmonic mean of three values <em>a</em>, <em>b</em> and <em>c</em> will be equivalent to <code>3/(1/a + 1/b + 1/c)</code>.</p> <p>The harmonic mean is a type of average, a measure of the central location of the data. It is often appropriate when averaging quantities which are rates or ratios, for example speeds. For example:</p> <p>Suppose an investor purchases an equal value of shares in each of three companies, with P/E (price/earning) ratios of 2.5, 3 and 10. What is the average P/E ratio for the investor’s portfolio?</p> <pre data-language="pycon3">&gt;&gt;&gt; harmonic_mean([2.5, 3, 10])  # For an equal investment portfolio.
3.6
</pre> <p>Using the arithmetic mean would give an average of about 5.167, which is too high.</p> <p><a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised if <em>data</em> is empty, or any element is less than zero.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 3.6.</span></p> </div> </dd>
</dl> <dl class="function"> <dt id="statistics.median">
<code>statistics.median(data)</code> </dt> <dd>
<p>Return the median (middle value) of numeric data, using the common “mean of middle two” method. If <em>data</em> is empty, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised. <em>data</em> can be a sequence or iterator.</p> <p>The median is a robust measure of central location, and is less affected by the presence of outliers in your data. When the number of data points is odd, the middle data point is returned:</p> <pre data-language="pycon3">&gt;&gt;&gt; median([1, 3, 5])
3
</pre> <p>When the number of data points is even, the median is interpolated by taking the average of the two middle values:</p> <pre data-language="pycon3">&gt;&gt;&gt; median([1, 3, 5, 7])
4.0
</pre> <p>This is suited for when your data is discrete, and you don’t mind that the median may not be an actual data point.</p> <p>If your data is ordinal (supports order operations) but not numeric (doesn’t support addition), you should use <a class="reference internal" href="#statistics.median_low" title="statistics.median_low"><code>median_low()</code></a> or <a class="reference internal" href="#statistics.median_high" title="statistics.median_high"><code>median_high()</code></a> instead.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p><a class="reference internal" href="#statistics.median_low" title="statistics.median_low"><code>median_low()</code></a>, <a class="reference internal" href="#statistics.median_high" title="statistics.median_high"><code>median_high()</code></a>, <a class="reference internal" href="#statistics.median_grouped" title="statistics.median_grouped"><code>median_grouped()</code></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="statistics.median_low">
<code>statistics.median_low(data)</code> </dt> <dd>
<p>Return the low median of numeric data. If <em>data</em> is empty, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised. <em>data</em> can be a sequence or iterator.</p> <p>The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned.</p> <pre data-language="pycon3">&gt;&gt;&gt; median_low([1, 3, 5])
3
&gt;&gt;&gt; median_low([1, 3, 5, 7])
3
</pre> <p>Use the low median when your data are discrete and you prefer the median to be an actual data point rather than interpolated.</p> </dd>
</dl> <dl class="function"> <dt id="statistics.median_high">
<code>statistics.median_high(data)</code> </dt> <dd>
<p>Return the high median of data. If <em>data</em> is empty, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised. <em>data</em> can be a sequence or iterator.</p> <p>The high median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the larger of the two middle values is returned.</p> <pre data-language="pycon3">&gt;&gt;&gt; median_high([1, 3, 5])
3
&gt;&gt;&gt; median_high([1, 3, 5, 7])
5
</pre> <p>Use the high median when your data are discrete and you prefer the median to be an actual data point rather than interpolated.</p> </dd>
</dl> <dl class="function"> <dt id="statistics.median_grouped">
<code>statistics.median_grouped(data, interval=1)</code> </dt> <dd>
<p>Return the median of grouped continuous data, calculated as the 50th percentile, using interpolation. If <em>data</em> is empty, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised. <em>data</em> can be a sequence or iterator.</p> <pre data-language="pycon3">&gt;&gt;&gt; median_grouped([52, 52, 53, 54])
52.5
</pre> <p>In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5–1.5, 2 is the midpoint of 1.5–2.5, 3 is the midpoint of 2.5–3.5, etc. With the data given, the middle value falls somewhere in the class 3.5–4.5, and interpolation is used to estimate it:</p> <pre data-language="pycon3">&gt;&gt;&gt; median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])
3.7
</pre> <p>Optional argument <em>interval</em> represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation:</p> <pre data-language="pycon3">&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=1)
3.25
&gt;&gt;&gt; median_grouped([1, 3, 3, 5, 7], interval=2)
3.5
</pre> <p>This function does not check whether the data points are at least <em>interval</em> apart.</p> <div class="impl-detail compound"> <p><strong>CPython implementation detail:</strong> Under some circumstances, <a class="reference internal" href="#statistics.median_grouped" title="statistics.median_grouped"><code>median_grouped()</code></a> may coerce data points to floats. This behaviour is likely to change in the future.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <ul class="simple"> <li>“Statistics for the Behavioral Sciences”, Frederick J Gravetter and Larry B Wallnau (8th Edition).</li> <li>Calculating the median.</li> <li>The SSMEDIAN function in the Gnome Gnumeric spreadsheet, including this discussion.</li> </ul> </div> </dd>
</dl> <dl class="function"> <dt id="statistics.mode">
<code>statistics.mode(data)</code> </dt> <dd>
<p>Return the most common data point from discrete or nominal <em>data</em>. The mode (when it exists) is the most typical value, and is a robust measure of central location.</p> <p>If <em>data</em> is empty, or if there is not exactly one most common value, <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> is raised.</p> <p><code>mode</code> assumes discrete data, and returns a single value. This is the standard treatment of the mode as commonly taught in schools:</p> <pre data-language="pycon3">&gt;&gt;&gt; mode([1, 1, 2, 3, 3, 3, 3, 4])
3
</pre> <p>The mode is unique in that it is the only statistic which also applies to nominal (non-numeric) data:</p> <pre data-language="pycon3">&gt;&gt;&gt; mode(["red", "blue", "blue", "red", "green", "red", "red"])
'red'
</pre> </dd>
</dl> <dl class="function"> <dt id="statistics.pstdev">
<code>statistics.pstdev(data, mu=None)</code> </dt> <dd>
<p>Return the population standard deviation (the square root of the population variance). See <a class="reference internal" href="#statistics.pvariance" title="statistics.pvariance"><code>pvariance()</code></a> for arguments and other details.</p> <pre data-language="pycon3">&gt;&gt;&gt; pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
0.986893273527251
</pre> </dd>
</dl> <dl class="function"> <dt id="statistics.pvariance">
<code>statistics.pvariance(data, mu=None)</code> </dt> <dd>
<p>Return the population variance of <em>data</em>, a non-empty iterable of real-valued numbers. Variance, or second moment about the mean, is a measure of the variability (spread or dispersion) of data. A large variance indicates that the data is spread out; a small variance indicates it is clustered closely around the mean.</p> <p>If the optional second argument <em>mu</em> is given, it should be the mean of <em>data</em>. If it is missing or <code>None</code> (the default), the mean is automatically calculated.</p> <p>Use this function to calculate the variance from the entire population. To estimate the variance from a sample, the <a class="reference internal" href="#statistics.variance" title="statistics.variance"><code>variance()</code></a> function is usually a better choice.</p> <p>Raises <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> if <em>data</em> is empty.</p> <p>Examples:</p> <pre data-language="pycon3">&gt;&gt;&gt; data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]
&gt;&gt;&gt; pvariance(data)
1.25
</pre> <p>If you have already calculated the mean of your data, you can pass it as the optional second argument <em>mu</em> to avoid recalculation:</p> <pre data-language="pycon3">&gt;&gt;&gt; mu = mean(data)
&gt;&gt;&gt; pvariance(data, mu)
1.25
</pre> <p>This function does not attempt to verify that you have passed the actual mean as <em>mu</em>. Using arbitrary values for <em>mu</em> may lead to invalid or impossible results.</p> <p>Decimals and Fractions are supported:</p> <pre data-language="pycon3">&gt;&gt;&gt; from decimal import Decimal as D
&gt;&gt;&gt; pvariance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
Decimal('24.815')

&gt;&gt;&gt; from fractions import Fraction as F
&gt;&gt;&gt; pvariance([F(1, 4), F(5, 4), F(1, 2)])
Fraction(13, 72)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When called with the entire population, this gives the population variance σ². When called on a sample instead, this is the biased sample variance s², also known as variance with N degrees of freedom.</p> <p>If you somehow know the true population mean μ, you may use this function to calculate the variance of a sample, giving the known population mean as the second argument. Provided the data points are representative (e.g. independent and identically distributed), the result will be an unbiased estimate of the population variance.</p> </div> </dd>
</dl> <dl class="function"> <dt id="statistics.stdev">
<code>statistics.stdev(data, xbar=None)</code> </dt> <dd>
<p>Return the sample standard deviation (the square root of the sample variance). See <a class="reference internal" href="#statistics.variance" title="statistics.variance"><code>variance()</code></a> for arguments and other details.</p> <pre data-language="pycon3">&gt;&gt;&gt; stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])
1.0810874155219827
</pre> </dd>
</dl> <dl class="function"> <dt id="statistics.variance">
<code>statistics.variance(data, xbar=None)</code> </dt> <dd>
<p>Return the sample variance of <em>data</em>, an iterable of at least two real-valued numbers. Variance, or second moment about the mean, is a measure of the variability (spread or dispersion) of data. A large variance indicates that the data is spread out; a small variance indicates it is clustered closely around the mean.</p> <p>If the optional second argument <em>xbar</em> is given, it should be the mean of <em>data</em>. If it is missing or <code>None</code> (the default), the mean is automatically calculated.</p> <p>Use this function when your data is a sample from a population. To calculate the variance from the entire population, see <a class="reference internal" href="#statistics.pvariance" title="statistics.pvariance"><code>pvariance()</code></a>.</p> <p>Raises <a class="reference internal" href="#statistics.StatisticsError" title="statistics.StatisticsError"><code>StatisticsError</code></a> if <em>data</em> has fewer than two values.</p> <p>Examples:</p> <pre data-language="pycon3">&gt;&gt;&gt; data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
&gt;&gt;&gt; variance(data)
1.3720238095238095
</pre> <p>If you have already calculated the mean of your data, you can pass it as the optional second argument <em>xbar</em> to avoid recalculation:</p> <pre data-language="pycon3">&gt;&gt;&gt; m = mean(data)
&gt;&gt;&gt; variance(data, m)
1.3720238095238095
</pre> <p>This function does not attempt to verify that you have passed the actual mean as <em>xbar</em>. Using arbitrary values for <em>xbar</em> can lead to invalid or impossible results.</p> <p>Decimal and Fraction values are supported:</p> <pre data-language="pycon3">&gt;&gt;&gt; from decimal import Decimal as D
&gt;&gt;&gt; variance([D("27.5"), D("30.25"), D("30.25"), D("34.5"), D("41.75")])
Decimal('31.01875')

&gt;&gt;&gt; from fractions import Fraction as F
&gt;&gt;&gt; variance([F(1, 6), F(1, 2), F(5, 3)])
Fraction(67, 108)
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is the sample variance s² with Bessel’s correction, also known as variance with N-1 degrees of freedom. Provided that the data points are representative (e.g. independent and identically distributed), the result should be an unbiased estimate of the true population variance.</p> <p>If you somehow know the actual population mean μ you should pass it to the <a class="reference internal" href="#statistics.pvariance" title="statistics.pvariance"><code>pvariance()</code></a> function as the <em>mu</em> parameter to get the variance of a sample.</p> </div> </dd>
</dl> <h2 id="exceptions">
<span class="section-number">9.7.4. </span>Exceptions</h2> <p>A single exception is defined:</p> <dl class="exception"> <dt id="statistics.StatisticsError">
<code>exception statistics.StatisticsError</code> </dt> <dd>
<p>Subclass of <a class="reference internal" href="exceptions#ValueError" title="ValueError"><code>ValueError</code></a> for statistics-related exceptions.</p> </dd>
</dl><div class="_attribution">
<p class="_attribution-p">
    © 2001–2020 Python Software Foundation<br/>Licensed under the PSF License.<br/>
https://docs.python.org/3.6/library/statistics.html
</p>
</div>
